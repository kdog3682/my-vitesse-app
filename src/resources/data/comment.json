[
  {
    "name": "/home/kdog3682/.config/nvim/lua/local-plugins/comment/lua/Comment/api.lua",
    "size": 8408,
    "text": "---@mod comment.api Core Lua API\n---@brief [[\n---This module provides the core lua APIs which is used by the default keybindings\n---and <Plug> (Read |comment.plugmap|) mappings. These API can be used to setup your\n---own custom keybindings or to even make your (un)comment function.\n---@brief ]]\n\nlocal Config = require('Comment.config')\nlocal U = require('Comment.utils')\nlocal Op = require('Comment.opfunc')\nlocal Ex = require('Comment.extra')\nlocal A = vim.api\n\nlocal api, core = {}, {}\n\n---API metamethods\n---@param that table\n---@param ctype CommentType\n---@return table\nfunction core.__index(that, ctype)\n    local idxd = {}\n    local mode, type = that.cmode, U.ctype[ctype]\n\n    ---To comment the current-line\n    ---NOTE:\n    ---In current-line linewise method, 'opmode' is not useful which is always equals to `char`\n    ---but we need 'nil' here which is used for current-line\n    function idxd.current(_, cfg)\n        U.catch(Op.opfunc, nil, cfg or Config:get(), mode, type)\n    end\n\n    ---To comment lines with a count\n    function idxd.count(count, cfg)\n        U.catch(Op.count, count or A.nvim_get_vvar('count'), cfg or Config:get(), mode, type)\n    end\n\n    ---@private\n    ---To comment lines with a count, also dot-repeatable\n    ---WARN: This is not part of the API but anyone case use it, if they want\n    function idxd.count_repeat(_, count, cfg)\n        idxd.count(count, cfg)\n    end\n\n    return setmetatable({}, {\n        __index = idxd,\n        __call = function(_, motion, cfg)\n            U.catch(Op.opfunc, motion, cfg or Config:get(), mode, type)\n        end,\n    })\nend\n\n---@tag comment.api.toggle.linewise\n---@tag comment.api.toggle.blockwise\n---Provides API to toggle comments over a region, on current-line, or with a\n---count using line or block comment string.\n---\n---Every function takes a {motion} argument, except '*.count()' function which\n---takes an {count} argument, and an optional {config} parameter.\n---@type table A metatable containing API functions\n---@see comment.opfunc.OpMotion\n---@see comment.config\n---@usage [[\n---local api = require('Comment.api')\n---local config = require('Comment.config'):get()\n---\n---api.toggle.linewise(motion, config?)\n---api.toggle.linewise.current(motion?, config?)\n---api.toggle.linewise.count(count, config?)\n---\n---api.toggle.blockwise(motion, config?)\n---api.toggle.blockwise.current(motion?, config?)\n---api.toggle.blockwise.count(count, config?)\n---\n----- Toggle current line (linewise) using C-/\n---vim.keymap.set('n', '<C-_>', api.toggle.linewise.current)\n---\n----- Toggle current line (blockwise) using C-\\\n---vim.keymap.set('n', '<C-\\\\>', api.toggle.blockwise.current)\n---\n----- Toggle lines (linewise) with dot-repeat support\n----- Example: <leader>gc3j will comment 4 lines\n---vim.keymap.set(\n---    'n', '<leader>gc', api.call('toggle.linewise', 'g@'),\n---    { expr = true }\n---)\n---\n----- Toggle lines (blockwise) with dot-repeat support\n----- Example: <leader>gb3j will comment 4 lines\n---vim.keymap.set(\n---    'n', '<leader>gb', api.call('toggle.blockwise', 'g@'),\n---    { expr = true }\n---)\n---\n---local esc = vim.api.nvim_replace_termcodes(\n---    '<ESC>', true, false, true\n---)\n---\n----- Toggle selection (linewise)\n---vim.keymap.set('x', '<leader>c', function()\n---    vim.api.nvim_feedkeys(esc, 'nx', false)\n---    api.toggle.linewise(vim.fn.visualmode())\n---end)\n---\n----- Toggle selection (blockwise)\n---vim.keymap.set('x', '<leader>b', function()\n---    vim.api.nvim_feedkeys(esc, 'nx', false)\n---    api.toggle.blockwise(vim.fn.visualmode())\n---end)\n---@usage ]]\napi.toggle = setmetatable({ cmode = U.cmode.toggle }, core)\n\n---@tag comment.api.comment.linewise\n---@tag comment.api.comment.blockwise\n---Provides API to (only) comment a region, on current-line, or with a\n---count using line or block comment string.\n---\n---Every function takes a {motion} argument, except '*.count()' function which\n---takes an {count} argument, and an optional {config} parameter.\n---@type table A metatable containing API functions\n---@see comment.opfunc.OpMotion\n---@see comment.config\n---@usage [[\n---local api = require('Comment.api')\n---local config = require('Comment.config'):get()\n---\n---api.comment.linewise(motion, config?)\n---api.comment.linewise.current(motion?, config?)\n---api.comment.linewise.count(count, config?)\n---\n---api.comment.blockwise(motion, config?)\n---api.comment.blockwise.current(motion?, config?)\n---api.comment.blockwise.count(count, config?)\n---@usage ]]\napi.comment = setmetatable({ cmode = U.cmode.comment }, core)\n\n---@tag comment.api.uncomment.linewise\n---@tag comment.api.uncomment.blockwise\n---Provides API to (only) uncomment a region, on current-line, or with a\n---count using line or block comment string.\n---\n---Every function takes a {motion} argument, except '*.count()' function which\n---takes an {count} argument, and an optional {config} parameter.\n---@type table A metatable containing API functions\n---@see comment.opfunc.OpMotion\n---@see comment.config\n---@usage [[\n---local api = require('Comment.api')\n---local config = require('Comment.config'):get()\n---\n---api.uncomment.linewise(motion, config?)\n---api.uncomment.linewise.current(motion?, config?)\n---api.uncomment.linewise.count(count, config?)\n---\n---api.uncomment.blockwise(motion, config?)\n---api.uncomment.blockwise.current(motion?, config?)\n---api.uncomment.blockwise.count(count, config?)\n---@usage ]]\napi.uncomment = setmetatable({ cmode = U.cmode.uncomment }, core)\n\n---Provides API to to insert comment on previous, next or at the end-of-line.\n---Every function takes an optional {config} parameter.\n---@type table A metatable containing API functions\n---@see comment.config\n---@usage [[\n---local api = require('Comment.api')\n---local config = require('Comment.config'):get()\n---\n---api.insert.linewise.above(config?)\n---api.insert.linewise.below(config?)\n---api.insert.linewise.eol(config?)\n---\n---api.insert.blockwise.above(config?)\n---api.insert.blockwise.below(config?)\n---api.insert.blockwise.eol(config?)\n---@usage ]]\napi.insert = setmetatable({}, {\n    __index = function(_, ctype)\n        return {\n            above = function(cfg)\n                U.catch(Ex.insert_above, U.ctype[ctype], cfg or Config:get())\n            end,\n            below = function(cfg)\n                U.catch(Ex.insert_below, U.ctype[ctype], cfg or Config:get())\n            end,\n            eol = function(cfg)\n                U.catch(Ex.insert_eol, U.ctype[ctype], cfg or Config:get())\n            end,\n        }\n    end,\n})\n\n---Wraps the given API function with 'lockmarks' to preserve marks/jumps\n---@param cb string Name of API function\n---@return fun(motion:OpMotion) #Callback function\n---@see lockmarks\n---@see comment.opfunc.OpMotion\n---@usage [[\n---local api = require('Comment.api')\n---\n---vim.keymap.set(\n---    'n', '<leader>c', api.locked('toggle.linewise.current')\n---)\n---\n---local esc = vim.api.nvim_replace_termcodes(\n---    '<ESC>', true, false, true\n---)\n---vim.keymap.set('x', '<leader>c', function()\n---    vim.api.nvim_feedkeys(esc, 'nx', false)\n---    api.locked('toggle.linewise')(vim.fn.visualmode())\n---end)\n---\n----- NOTE: `locked` method is just a wrapper around `lockmarks`\n---vim.api.nvim_command([[\n---    lockmarks lua require('Comment.api').toggle.linewise.current()\n---]])\n---@usage ]]\nfunction api.locked(cb)\n    return function(motion)\n        return A.nvim_command(\n            ('lockmarks lua require(\"Comment.api\").%s(%s)'):format(cb, motion and ('%q'):format(motion))\n        )\n    end\nend\n\n---Callback function which does the following\n---  1. Sets 'operatorfunc' for dot-repeat\n---  2. Preserves jumps and marks\n---  3. Stores last cursor position\n---@param cb string Name of the API function to call\n---@param op '\"g@\"'|'\"g@$\"' Operator-mode expression\n---@return fun():string #Keymap RHS callback\n---@see g@\n---@see operatorfunc\n---@usage [[\n---local api = require('Comment.api')\n---vim.keymap.set(\n---    'n', 'gc', api.call('toggle.linewise', 'g@'),\n---    { expr = true }\n---)\n---vim.keymap.set(\n---    'n', 'gcc', api.call('toggle.linewise.current', 'g@$'),\n---    { expr = true }\n---)\n---@usage ]]\nfunction api.call(cb, op)\n    return function()\n        A.nvim_set_option('operatorfunc', (\"v:lua.require'Comment.api'.locked'%s'\"):format(cb))\n        Config.position = Config:get().sticky and A.nvim_win_get_cursor(0) or nil\n        return op\n    end\nend\n\nreturn api\n"
  },
  {
    "name": "/home/kdog3682/.config/nvim/lua/local-plugins/comment/lua/Comment/config.lua",
    "size": 3841,
    "text": "---@mod comment.config Configuration\n---@tag comment.config.defaults\n---@brief [[\n---Following is the default config for the |comment.usage.setup|. If you want to\n---override, just modify the option that you want, then it will be merged with the\n---default config.\n--->lua\n---  {\n---      padding = true,\n---      sticky = true,\n---      ignore = nil,\n---      toggler = { line = 'gcc', block = 'gbc' },\n---      opleader = { line = 'gc', block = 'gb' },\n---      extra = { above = 'gcO', below = 'gco', eol = 'gcA' },\n---      mappings = { basic = true, extra = true },\n---      pre_hook = nil,\n---      post_hook = nil,\n---  }\n---<\n---@brief ]]\n\n---Plugin's configuration\n---@class CommentConfig\n---Controls space between the comment\n---and the line (default: 'true')\n---@field padding boolean|fun():boolean\n---Whether cursor should stay at the\n---same position. Only works in NORMAL\n---mode mappings (default: 'true')\n---@field sticky boolean\n---Lua pattern used to ignore lines\n---during (un)comment (default: 'nil')\n---@field ignore string|fun():string\n---Enables |comment.keybindings|\n---NOTE: If given 'false', then the\n---plugin won't create any mappings\n---@field mappings Mappings|false\n---@field toggler Toggler See |comment.config.Toggler|\n---@field opleader Opleader See |comment.config.Opleader|\n---@field extra ExtraMapping See |comment.config.ExtraMapping|\n---Function to call before (un)comment.\n---It is called with a {ctx} argument\n---of type |comment.utils.CommentCtx|\n---(default: 'nil')\n---@field pre_hook fun(c: CommentCtx): string\n---Function to call after (un)comment.\n---It is called with a {ctx} argument\n---of type |comment.utils.CommentCtx|\n---(default: 'nil')\n---@field post_hook fun(c: CommentCtx)\n\n---Create default mappings\n---@class Mappings\n---Enables operator-pending mapping; `gcc`, `gbc`,\n---`gc{motion}` and `gb{motion}` (default: 'true')\n---@field basic boolean\n---Enable extra mapping; `gco`, `gcO` and `gcA`\n---(default: 'true')\n---@field extra boolean\n\n---LHS of toggle mappings in NORMAL\n---@class Toggler\n---@field line string Linewise comment (default: 'gcc')\n---@field block string Blockwise comment (default: 'gbc')\n\n---LHS of operator-mode mappings in NORMAL and VISUAL mode\n---@class Opleader\n---@field line string Linewise comment (default: 'gc')\n---@field block string Blockwise comment (default: 'gb')\n\n---LHS of extra mappings\n---@class ExtraMapping\n---@field below string Inserts comment below (default: 'gco')\n---@field above string Inserts comment above (default: 'gcO')\n---@field eol string Inserts comment at the end of line (default: 'gcA')\n\n---@private\n---@class RootConfig\n---@field config CommentConfig\n---@field position? integer[] To be used to restore cursor position\nlocal Config = {\n    state = {},\n    config = {\n        padding = true,\n        sticky = true,\n        mappings = {\n            basic = true,\n            extra = true,\n        },\n        toggler = {\n            line = 'gcc',\n            block = 'gbc',\n        },\n        opleader = {\n            line = 'gc',\n            block = 'gb',\n        },\n        extra = {\n            above = 'gcO',\n            below = 'gco',\n            eol = 'gcA',\n        },\n    },\n}\n\n---@package\n---Updates the default config\n---@param cfg? CommentConfig\n---@return RootConfig\n---@see comment.usage.setup\n---@usage `require('Comment.config'):set({config})`\nfunction Config:set(cfg)\n    if cfg then\n        self.config = vim.tbl_deep_extend('force', self.config, cfg)\n    end\n    return self\nend\n\n---Get the config\n---@return CommentConfig\n---@usage `require('Comment.config'):get()`\nfunction Config:get()\n    return self.config\nend\n\n---@export Config\nreturn setmetatable(Config, {\n    __index = function(this, k)\n        return this.state[k]\n    end,\n    __newindex = function(this, k, v)\n        this.state[k] = v\n    end,\n})\n"
  },
  {
    "name": "/home/kdog3682/.config/nvim/lua/local-plugins/comment/lua/Comment/extra.lua",
    "size": 3544,
    "text": "---@mod comment.extra Extra API\n---@brief [[\n---Underlying functions that powers the |comment.api.insert| lua API.\n---@brief ]]\n\nlocal U = require('Comment.utils')\nlocal A = vim.api\n\nlocal extra = {}\n\n-- FIXME This prints `a` in i_CTRL-o\n---Moves the cursor and enters INSERT mode\n---@param row integer Starting row\n---@param col integer Ending column\nlocal function move_n_insert(row, col)\n    A.nvim_win_set_cursor(0, { row, col })\n    A.nvim_feedkeys('a', 'ni', true)\nend\n\n---@param lnum integer Line index\n---@param ctype integer\n---@param cfg CommentConfig\nlocal function ins_on_line(lnum, ctype, cfg)\n    local row, col = unpack(A.nvim_win_get_cursor(0))\n\n    ---@type CommentCtx\n    local ctx = {\n        cmode = U.cmode.comment,\n        cmotion = U.cmotion.line,\n        ctype = ctype,\n        range = { srow = row, scol = col, erow = row, ecol = col },\n    }\n\n    local srow = row + lnum\n    local lcs, rcs = U.parse_cstr(cfg, ctx)\n    local padding = U.get_pad(U.is_fn(cfg.padding))\n\n    -- We need RHS of cstr, if we are doing block comments or if RHS exists\n    -- because even in line comment RHS do exists for some filetypes like jsx_element, ocaml\n    local if_rcs = U.is_empty(rcs) and rcs or padding .. rcs\n\n    A.nvim_buf_set_lines(0, srow, srow, false, { lcs .. padding .. if_rcs })\n    A.nvim_win_set_cursor(0, { srow + 1, 0 })\n    A.nvim_command('normal! ==')\n    move_n_insert(srow + 1, #A.nvim_get_current_line() - #if_rcs - 1)\n    U.is_fn(cfg.post_hook, ctx)\nend\n\n---Add a comment below the current line and goes to INSERT mode\n---@param ctype integer See |comment.utils.ctype|\n---@param cfg CommentConfig\nfunction extra.insert_below(ctype, cfg)\n    ins_on_line(0, ctype, cfg)\nend\n\n---Add a comment above the current line and goes to INSERT mode\n---@param ctype integer See |comment.utils.ctype|\n---@param cfg CommentConfig\nfunction extra.insert_above(ctype, cfg)\n    ins_on_line(-1, ctype, cfg)\nend\n\n---Add a comment at the end of current line and goes to INSERT mode\n---@param ctype integer See |comment.utils.ctype|\n---@param cfg CommentConfig\nfunction extra.insert_eol(ctype, cfg)\n    local srow, scol = unpack(A.nvim_win_get_cursor(0))\n\n    ---@type CommentCtx\n    local ctx = {\n        cmode = U.cmode.comment,\n        cmotion = U.cmotion.line,\n        ctype = ctype,\n        range = { srow = srow, scol = scol, erow = srow, ecol = scol },\n    }\n    local lcs, rcs = U.parse_cstr(cfg, ctx)\n\n    local line = A.nvim_get_current_line()\n    local padding = U.get_pad(U.is_fn(cfg.padding))\n\n    -- We need RHS of cstr, if we are doing block comments or if RHS exists\n    -- because even in line comment RHS do exists for some filetypes like jsx_element, ocaml\n    local if_rcs = U.is_empty(rcs) and rcs or padding .. rcs\n\n    local ecol\n    if U.is_empty(line) then\n        -- If line is empty, start comment at the correct indentation level\n        A.nvim_set_current_line(lcs .. padding .. if_rcs)\n        A.nvim_command('normal! ==')\n        ecol = #A.nvim_get_current_line() - #if_rcs - 1\n    else\n        -- NOTE:\n        -- 1. Python is the only language that recommends 2 spaces between the statement and the comment\n        -- 2. Other than that, I am assuming that the users wants a space b/w the end of line and start of the comment\n        local space = vim.bo.filetype == 'python' and '  ' or ' '\n        local ll = line .. space .. lcs .. padding\n        A.nvim_set_current_line(ll .. if_rcs)\n        ecol = #ll - 1\n    end\n\n    move_n_insert(srow, ecol)\n    U.is_fn(cfg.post_hook, ctx)\nend\n\nreturn extra\n"
  },
  {
    "name": "/home/kdog3682/.config/nvim/lua/local-plugins/comment/lua/Comment/ft.lua",
    "size": 9427,
    "text": "---@mod comment.ft Language/Filetype detection\n---@brief [[\n---This module is the core of filetype and commentstring detection and uses the\n---|lua-treesitter| APIs to accurately detect filetype and gives the corresponding\n---commentstring, stored inside the plugin, for the filetype/langauge.\n---\n---Compound (dot-separated) filetypes are also supported i.e. 'ansible.yaml',\n---'ios.swift' etc. The commentstring resolution will be done from left to right.\n---For example, If the filetype is 'ansible.yaml' then 'ansible' commenstring will\n---be used if found otherwise it'll fallback to 'yaml'. Read `:h 'filetype'`\n---@brief ]]\n\nlocal A = vim.api\n\n---Common commentstring shared b/w multiple languages\nlocal M = {\n    cxx_l = '//%s',\n    cxx_b = '/*%s*/',\n    dbl_hash = '##%s',\n    dash = '--%s',\n    dash_bracket = '--[[%s]]',\n    handlebars = '{{!--%s--}}',\n    hash = '#%s',\n    hash_bracket = '#[[%s]]',\n    haskell_b = '{-%s-}',\n    fsharp_b = '(*%s*)',\n    html = '<!--%s-->',\n    latex = '%%s',\n    semicolon = ';%s',\n    lisp_l = ';;%s',\n    lisp_b = '#|%s|#',\n    twig = '{#%s#}',\n    vim = '\"%s',\n    lean_b = '/-%s-/',\n}\n\n---Lang table that contains commentstring (linewise/blockwise) for multiple filetypes\n---Structure = { filetype = { linewise, blockwise } }\n---@type table<string,string[]>\nlocal L = setmetatable({\n    arduino = { M.cxx_l, M.cxx_b },\n    applescript = { M.hash },\n    astro = { M.html },\n    autohotkey = { M.semicolon, M.cxx_b },\n    bash = { M.hash },\n    beancount = { M.semicolon },\n    bib = { M.latex },\n    c = { M.cxx_l, M.cxx_b },\n    cabal = { M.dash },\n    cmake = { M.hash, M.hash_bracket },\n    conf = { M.hash },\n    conkyrc = { M.dash, M.dash_bracket },\n    coq = { M.fsharp_b },\n    cpp = { M.cxx_l, M.cxx_b },\n    cs = { M.cxx_l, M.cxx_b },\n    css = { M.cxx_b, M.cxx_b },\n    cuda = { M.cxx_l, M.cxx_b },\n    dart = { M.cxx_l, M.cxx_b },\n    dhall = { M.dash, M.haskell_b },\n    dosbatch = { 'REM%s' },\n    dot = { M.cxx_l, M.cxx_b },\n    dts = { M.cxx_l, M.cxx_b },\n    editorconfig = { M.hash },\n    eelixir = { M.html, M.html },\n    elixir = { M.hash },\n    elm = { M.dash, M.haskell_b },\n    elvish = { M.hash },\n    faust = { M.cxx_l, M.cxx_b },\n    fennel = { M.semicolon },\n    fish = { M.hash },\n    func = { M.lisp_l },\n    fsharp = { M.cxx_l, M.fsharp_b },\n    gdb = { M.hash },\n    gdscript = { M.hash },\n    gitignore = { M.hash },\n    gleam = { M.cxx_l },\n    glsl = { M.cxx_l, M.cxx_b },\n    gnuplot = { M.hash, M.hash_bracket },\n    go = { M.cxx_l, M.cxx_b },\n    gomod = { M.cxx_l },\n    graphql = { M.hash },\n    groovy = { M.cxx_l, M.cxx_b },\n    handlebars = { M.handlebars, M.handlebars },\n    haskell = { M.dash, M.haskell_b },\n    haxe = { M.cxx_l, M.cxx_b },\n    heex = { M.html, M.html },\n    html = { M.html, M.html },\n    htmldjango = { M.html, M.html },\n    idris = { M.dash, M.haskell_b },\n    idris2 = { M.dash, M.haskell_b },\n    ini = { M.hash },\n    java = { M.cxx_l, M.cxx_b },\n    javascript = { M.cxx_l, M.cxx_b },\n    javascriptreact = { M.cxx_l, M.cxx_b },\n    jsonc = { M.cxx_l },\n    jsonnet = { M.cxx_l, M.cxx_b },\n    julia = { M.hash, '#=%s=#' },\n    kotlin = { M.cxx_l, M.cxx_b },\n    lean = { M.dash, M.lean_b },\n    lean3 = { M.dash, M.lean_b },\n    lidris = { M.dash, M.haskell_b },\n    lilypond = { M.latex, '%{%s%}' },\n    lisp = { M.lisp_l, M.lisp_b },\n    lua = { M.dash, M.dash_bracket },\n    luau = { M.dash, M.dash_bracket },\n    markdown = { M.html, M.html },\n    make = { M.hash },\n    mbsyncrc = { M.dbl_hash },\n    mermaid = { '%%%s' },\n    meson = { M.hash },\n    nextflow = { M.cxx_l, M.cxx_b },\n    nim = { M.hash, '#[%s]#' },\n    nix = { M.hash, M.cxx_b },\n    nu = { M.hash },\n    ocaml = { M.fsharp_b, M.fsharp_b },\n    odin = { M.cxx_l, M.cxx_b },\n    plantuml = { \"'%s\", \"/'%s'/\" },\n    purescript = { M.dash, M.haskell_b },\n    python = { M.hash }, -- Python doesn't have block comments\n    php = { M.cxx_l, M.cxx_b },\n    prisma = { M.cxx_l },\n    proto = { M.cxx_l, M.cxx_b },\n    quarto = { M.html, M.html },\n    r = { M.hash }, -- R doesn't have block comments\n    racket = { M.lisp_l, M.lisp_b },\n    rasi = { M.cxx_l, M.cxx_b },\n    readline = { M.hash },\n    rego = { M.hash },\n    remind = { M.hash },\n    rescript = { M.cxx_l, M.cxx_b },\n    robot = { M.hash }, -- Robotframework doesn't have block comments\n    ron = { M.cxx_l, M.cxx_b },\n    ruby = { M.hash },\n    rust = { M.cxx_l, M.cxx_b },\n    sbt = { M.cxx_l, M.cxx_b },\n    scala = { M.cxx_l, M.cxx_b },\n    scheme = { M.lisp_l, M.lisp_b },\n    sh = { M.hash },\n    solidity = { M.cxx_l, M.cxx_b },\n    supercollider = { M.cxx_l, M.cxx_b },\n    sql = { M.dash, M.cxx_b },\n    stata = { M.cxx_l, M.cxx_b },\n    svelte = { M.html, M.html },\n    swift = { M.cxx_l, M.cxx_b },\n    sxhkdrc = { M.hash },\n    tablegen = { M.cxx_l, M.cxx_b },\n    teal = { M.dash, M.dash_bracket },\n    terraform = { M.hash, M.cxx_b },\n    tex = { M.latex },\n    template = { M.dbl_hash },\n    tmux = { M.hash },\n    toml = { M.hash },\n    twig = { M.twig, M.twig },\n    typescript = { M.cxx_l, M.cxx_b },\n    typescriptreact = { M.cxx_l, M.cxx_b },\n    typst = { M.cxx_l, M.cxx_b },\n    v = { M.cxx_l, M.cxx_b },\n    verilog = { M.cxx_l },\n    vhdl = { M.dash },\n    vim = { M.vim },\n    vifm = { M.vim },\n    vue = { M.html, M.html },\n    xdefaults = { '!%s' },\n    xml = { M.html, M.html },\n    xonsh = { M.hash }, -- Xonsh doesn't have block comments\n    yaml = { M.hash },\n    yuck = { M.lisp_l },\n    zig = { M.cxx_l }, -- Zig doesn't have block comments\n}, {\n    -- Support for compound filetype i.e. 'ios.swift', 'ansible.yaml' etc.\n    __index = function(this, k)\n        local base, fallback = string.match(k, '^(.-)%.(.*)')\n        if not (base or fallback) then\n            return nil\n        end\n        return this[base] or this[fallback]\n    end,\n})\n\nlocal ft = {}\n\n---Sets a commentstring(s) for a filetype/language\n---@param lang string Filetype/Language of the buffer\n---@param val string|string[]\n---@return table self Returns itself\n---@usage [[\n---local ft = require('Comment.ft')\n---\n-----1. Using method signature\n----- Set only line comment or both\n----- You can also chain the set calls\n---ft.set('yaml', '#%s').set('javascript', {'//%s', '/*%s*/'})\n---\n----- 2. Metatable magic\n---ft.javascript = {'//%s', '/*%s*/'}\n---ft.yaml = '#%s'\n---\n----- 3. Multiple filetypes\n---ft({'go', 'rust'}, {'//%s', '/*%s*/'})\n---ft({'toml', 'graphql'}, '#%s')\n---@usage ]]\nfunction ft.set(lang, val)\n    L[lang] = type(val) == 'string' and { val } or val --[[ @as string[] ]]\n    return ft\nend\n\n---Get line/block/both commentstring(s) for a given filetype\n---@param lang string Filetype/Language of the buffer\n---@param ctype? integer See |comment.utils.ctype|. If given `nil`, it'll\n---return a copy of { line, block } commentstring.\n---@return nil|string|string[] #Returns stored commentstring\n---@usage [[\n---local ft = require('Comment.ft')\n---local U = require('Comment.utils')\n---\n----- 1. Primary filetype\n---ft.get('rust', U.ctype.linewise) -- `//%s`\n---ft.get('rust') -- `{ '//%s', '/*%s*/' }`\n---\n----- 2. Compound filetype\n----- NOTE: This will return `yaml` commenstring(s),\n-----       as `ansible` commentstring is not found.\n---ft.get('ansible.yaml', U.ctype.linewise) -- `#%s`\n---ft.get('ansible.yaml') -- { '#%s' }\n---@usage ]]\nfunction ft.get(lang, ctype)\n    local tuple = L[lang]\n    if not tuple then\n        return nil\n    end\n    if not ctype then\n        return vim.deepcopy(tuple)\n    end\n    return tuple[ctype]\nend\n\n---Get a language tree for a given range by walking the parse tree recursively.\n---This uses 'lua-treesitter' API under the hood. This can be used to calculate\n---language of a particular region which embedded multiple filetypes like html,\n---vue, markdown etc.\n---\n---NOTE: This ignores `tree-sitter-comment` parser, if installed.\n---@param tree userdata Parse tree to be walked\n---@param range integer[] Range to check\n---{start_row, start_col, end_row, end_col}\n---@return userdata #Returns a |treesitter-languagetree|\n---@see treesitter-languagetree\n---@see lua-treesitter-core\n---@usage [[\n---local ok, parser = pcall(vim.treesitter.get_parser, 0)\n---assert(ok, \"No parser found!\")\n---local tree = require('Comment.ft').contains(parser, {0, 0, -1, 0})\n---print('Lang:', tree:lang())\n---@usage ]]\nfunction ft.contains(tree, range)\n    for lang, child in pairs(tree:children()) do\n        if lang ~= 'comment' and child:contains(range) then\n            return ft.contains(child, range)\n        end\n    end\n\n    return tree\nend\n\n---Calculate commentstring with the power of treesitter\n---@param ctx CommentCtx\n---@return nil|string #Commentstring\n---@see comment.utils.CommentCtx\nfunction ft.calculate(ctx)\n    local ok, parser = pcall(vim.treesitter.get_parser, A.nvim_get_current_buf())\n\n    if not ok then\n        return ft.get(vim.bo.filetype, ctx.ctype) --[[ @as string ]]\n    end\n\n    local lang = ft.contains(parser, {\n        ctx.range.srow - 1,\n        ctx.range.scol,\n        ctx.range.erow - 1,\n        ctx.range.ecol,\n    }):lang()\n\n    return ft.get(lang, ctx.ctype) or ft.get(vim.bo.filetype, ctx.ctype) --[[ @as string ]]\nend\n\n---@export ft\nreturn setmetatable(ft, {\n    __newindex = function(this, k, v)\n        this.set(k, v)\n    end,\n    __call = function(this, langs, spec)\n        for _, lang in ipairs(langs) do\n            this.set(lang, spec)\n        end\n        return this\n    end,\n})\n"
  },
  {
    "name": "/home/kdog3682/.config/nvim/lua/local-plugins/comment/lua/Comment/init.lua",
    "size": 5391,
    "text": "---@brief [[\n---*comment-nvim.txt*    For Neovim version 0.7           Last change: 2021 July 11\n---\n---     _____                                     _                _\n---    / ____/                                   / /              (_)\n---   / /     ___  _ __ ___  _ __ ___   ___ _ __ / /_   _ ____   ___ _ __ ___\n---   / /    / _ \\/ '_ ` _ \\/ '_ ` _ \\ / _ \\ '_ \\/ __/ / '_ \\ \\ / / / '_ ` _ \\\n---   / /___/ (_) / / / / / / / / / / /  __/ / / / /_ _/ / / \\ V // / / / / / /\n---    \\_____\\___//_/ /_/ /_/_/ /_/ /_/\\___/_/ /_/\\__(_)_/ /_/\\_/ /_/_/ /_/ /_/\n---\n---                    · Smart and Powerful comment plugin ·\n---\n---@brief ]]\n\n---@toc comment.contents\n\n---@mod comment-nvim Introduction\n---@brief [[\n---Comment.nvim is a smart and powerful comment plugin for neovim. It supports\n---dot-repeat, counts, line ('//') and block ('/* */') comments, and can be used\n---with motion and text-objects. It has native integration with |treesitter| to\n---support embedded filetypes like html, vue, markdown with codeblocks etc.\n---@brief ]]\n---@tag comment.dotrepeat\n---@brief [[\n---Comment.nvim uses |operatorfunc| combined with |g@| to support dot-repeat, and\n---various marks i.e., |'[| |']| |'<| |'>| to deduce the region with the {motion}\n---argument provided by 'operatorfunc'. See |comment.api.call|\n---@brief ]]\n---@tag comment.commentstring\n---@brief [[\n---Comment.nvim picks commentstring, either linewise/blockwise, from one of the\n---following places\n---\n--- 1. 'pre_hook'\n---       If a string is returned from this function then it will be used for\n---       (un)commenting. See |comment.config|\n---\n--- 2. |comment.ft|\n---       Using the commentstring table inside the plugin (using treesitter).\n---       Fallback to |commentstring|, if not found.\n---\n--- 3. |commentstring| - Neovim's native commentstring for the filetype\n---\n---Although Comment.nvim supports native 'commentstring' but unfortunately it has\n---the least priority. The caveat with this approach is that if someone sets the\n---`commentstring`, without returning it, from the 'pre_hook' and the current\n---filetype also exists in the |comment.ft| then the commenting will be done using\n---the string in |comment.ft| instead of using 'commentstring'. To override this\n---behavior, you have to manually return the 'commentstring' from 'pre_hook'.\n---@brief ]]\n---@tag comment.sourcecode\n---@brief [[\n---Comment.nvim is FOSS and distributed under MIT license. All the source code is\n---available at https://github.com/numToStr/Comment.nvim\n---@brief ]]\n\n---@mod comment.usage Usage\n---@brief [[\n---Before using the plugin, you need to call the `setup()` function to create the\n---default mappings. If you want, you can also override the default configuration\n---by giving it a partial 'comment.config.Config' object, it will then be merged\n---with the default configuration.\n---@brief ]]\n\nlocal C = {}\n\n---Configures the plugin\n---@param config? CommentConfig User configuration\n---@return CommentConfig #Returns the modified config\n---@see comment.config\n---@usage [[\n----- Use default configuration\n---require('Comment').setup()\n---\n----- or with custom configuration\n---require('Comment').setup({\n---    ignore = '^$',\n---    toggler = {\n---        line = '<leader>cc',\n---        block = '<leader>bc',\n---    },\n---    opleader = {\n---        line = '<leader>c',\n---        block = '<leader>b',\n---    },\n---})\n---@usage ]]\nfunction C.setup(config)\n    local cfg = require('Comment.config'):set(config):get()\n\n    if cfg.mappings then\n        local api = require('Comment.api')\n        local vvar = vim.api.nvim_get_vvar\n        local K = vim.keymap.set\n\n        -- Basic Mappings\n        if cfg.mappings.basic then\n            -- NORMAL mode mappings\n            K('n', cfg.opleader.line, '<Plug>(comment_toggle_linewise)', { desc = 'Comment toggle linewise' })\n            K('n', cfg.opleader.block, '<Plug>(comment_toggle_blockwise)', { desc = 'Comment toggle blockwise' })\n\n            K('n', cfg.toggler.line, function()\n                return vvar('count') == 0 and '<Plug>(comment_toggle_linewise_current)'\n                    or '<Plug>(comment_toggle_linewise_count)'\n            end, { expr = true, desc = 'Comment toggle current line' })\n            K('n', cfg.toggler.block, function()\n                return vvar('count') == 0 and '<Plug>(comment_toggle_blockwise_current)'\n                    or '<Plug>(comment_toggle_blockwise_count)'\n            end, { expr = true, desc = 'Comment toggle current block' })\n\n            -- VISUAL mode mappings\n            K(\n                'x',\n                cfg.opleader.line,\n                '<Plug>(comment_toggle_linewise_visual)',\n                { desc = 'Comment toggle linewise (visual)' }\n            )\n            K(\n                'x',\n                cfg.opleader.block,\n                '<Plug>(comment_toggle_blockwise_visual)',\n                { desc = 'Comment toggle blockwise (visual)' }\n            )\n        end\n\n        -- Extra Mappings\n        if cfg.mappings.extra then\n            K('n', cfg.extra.below, api.insert.linewise.below, { desc = 'Comment insert below' })\n            K('n', cfg.extra.above, api.insert.linewise.above, { desc = 'Comment insert above' })\n            K('n', cfg.extra.eol, api.locked('insert.linewise.eol'), { desc = 'Comment insert end of line' })\n        end\n    end\n\n    return cfg\nend\n\nreturn C\n"
  },
  {
    "name": "/home/kdog3682/.config/nvim/lua/local-plugins/comment/lua/Comment/opfunc.lua",
    "size": 7567,
    "text": "---@mod comment.opfunc Operator-mode API\n---@brief [[\n---Underlying functions that powers the |comment.api.toggle|, |comment.api.comment|,\n---and |comment.api.uncomment| lua API.\n---@brief ]]\n\nlocal U = require('Comment.utils')\nlocal Config = require('Comment.config')\nlocal A = vim.api\n\nlocal Op = {}\n\n---Vim operator-mode motion enum. Read |:map-operator|\n---@alias OpMotion\n---| '\"line\"' # Vertical motion\n---| '\"char\"' # Horizontal motion\n---| '\"v\"' # Visual Block motion\n---| '\"V\"' # Visual Line motion\n\n---Common operatorfunc callback\n---This function contains the core logic for comment/uncomment\n---@param motion? OpMotion\n---If given 'nil', it'll only (un)comment\n---the current line\n---@param cfg CommentConfig\n---@param cmode integer See |comment.utils.cmode|\n---@param ctype integer See |comment.utils.ctype|\nfunction Op.opfunc(motion, cfg, cmode, ctype)\n    local range = U.get_region(motion)\n    local cmotion = motion == nil and U.cmotion.line or U.cmotion[motion]\n\n    -- If we are doing char or visual motion on the same line\n    -- then we would probably want block comment instead of line comment\n    local is_partial = cmotion == U.cmotion.char or cmotion == U.cmotion.v\n    local is_blockx = is_partial and range.srow == range.erow\n\n    local lines = U.get_lines(range)\n\n    -- sometimes there might be a case when there are no lines\n    -- like, executing a text object returns nothing\n    if U.is_empty(lines) then\n        return\n    end\n\n    ---@type CommentCtx\n    local ctx = {\n        cmode = cmode,\n        cmotion = cmotion,\n        ctype = is_blockx and U.ctype.blockwise or ctype,\n        range = range,\n    }\n\n    local lcs, rcs = U.parse_cstr(cfg, ctx)\n\n    ---@type OpFnParams\n    local params = {\n        cfg = cfg,\n        lines = lines,\n        lcs = lcs,\n        rcs = rcs,\n        cmode = cmode,\n        range = range,\n    }\n\n    if motion ~= nil and (is_blockx or ctype == U.ctype.blockwise) then\n        ctx.cmode = Op.blockwise(params, is_partial)\n    else\n        ctx.cmode = Op.linewise(params)\n    end\n\n    -- We only need to restore cursor if both sticky and position are available\n    -- As this function is also called for visual mapping where we are not storing the position\n    --\n    -- And I found out that if someone presses `gc` but doesn't provide operators and\n    -- does visual comments then cursor jumps to previous stored position. Thus the check for visual modes\n    if cfg.sticky and Config.position and cmotion ~= U.cmotion.v and cmotion ~= U.cmotion.V then\n        A.nvim_win_set_cursor(0, Config.position)\n        Config.position = nil\n    end\n\n    U.is_fn(cfg.post_hook, ctx)\nend\n\n---Line commenting with count\n---@param count integer Value of |v:count|\n---@param cfg CommentConfig\n---@param cmode integer See |comment.utils.cmode|\n---@param ctype integer See |comment.utils.ctype|\nfunction Op.count(count, cfg, cmode, ctype)\n    local lines, range = U.get_count_lines(count)\n\n    ---@type CommentCtx\n    local ctx = {\n        cmode = cmode,\n        cmotion = U.cmotion.line,\n        ctype = ctype,\n        range = range,\n    }\n    local lcs, rcs = U.parse_cstr(cfg, ctx)\n\n    ---@type OpFnParams\n    local params = {\n        cfg = cfg,\n        cmode = ctx.cmode,\n        lines = lines,\n        lcs = lcs,\n        rcs = rcs,\n        range = range,\n    }\n\n    if ctype == U.ctype.blockwise then\n        ctx.cmode = Op.blockwise(params)\n    else\n        ctx.cmode = Op.linewise(params)\n    end\n\n    U.is_fn(cfg.post_hook, ctx)\nend\n\n---Operator-mode function parameters\n---@class OpFnParams\n---@field cfg CommentConfig\n---@field cmode integer See |comment.utils.cmode|\n---@field lines string[] List of lines\n---@field rcs string RHS of commentstring\n---@field lcs string LHS of commentstring\n---@field range CommentRange\n\n---Line commenting\n---@param param OpFnParams\n---@return integer _ Returns a calculated comment mode\nfunction Op.linewise(param)\n    local pattern = U.is_fn(param.cfg.ignore)\n    local padding = U.is_fn(param.cfg.padding)\n    local check_comment = U.is_commented(param.lcs, param.rcs, padding)\n\n    -- While commenting a region, there could be lines being both commented and non-commented\n    -- So, if any line is uncommented then we should comment the whole block or vise-versa\n    local cmode = U.cmode.uncomment\n\n    ---When commenting multiple line, it is to be expected that indentation should be preserved\n    ---So, When looping over multiple lines we need to store the indentation of the mininum length (except empty line)\n    ---Which will be used to semantically comment rest of the lines\n    local min_indent, tabbed = -1, false\n\n    -- If the given cmode is uncomment then we actually don't want to compute the cmode or min_indent\n    if param.cmode ~= U.cmode.uncomment then\n        for _, line in ipairs(param.lines) do\n            -- I wish lua had `continue` statement [sad noises]\n            if not U.ignore(line, pattern) then\n                if cmode == U.cmode.uncomment and param.cmode == U.cmode.toggle and (not check_comment(line)) then\n                    cmode = U.cmode.comment\n                end\n\n                if not U.is_empty(line) and param.cmode ~= U.cmode.uncomment then\n                    local _, len = string.find(line, '^%s*')\n                    if min_indent == -1 or min_indent > len then\n                        min_indent, tabbed = len, string.find(line, '^\\t') ~= nil\n                    end\n                end\n            end\n        end\n    end\n\n    -- If the comment mode given is not toggle than force that mode\n    if param.cmode ~= U.cmode.toggle then\n        cmode = param.cmode\n    end\n\n    if cmode == U.cmode.uncomment then\n        local uncomment = U.uncommenter(param.lcs, param.rcs, padding)\n        for i, line in ipairs(param.lines) do\n            if not U.ignore(line, pattern) then\n                param.lines[i] = uncomment(line) --[[@as string]]\n            end\n        end\n    else\n        local comment = U.commenter(param.lcs, param.rcs, padding, min_indent, nil, tabbed)\n        for i, line in ipairs(param.lines) do\n            if not U.ignore(line, pattern) then\n                param.lines[i] = comment(line) --[[@as string]]\n            end\n        end\n    end\n\n    A.nvim_buf_set_lines(0, param.range.srow - 1, param.range.erow, false, param.lines)\n\n    return cmode\nend\n\n---Full/Partial/Current-Line Block commenting\n---@param param OpFnParams\n---@param partial? boolean Comment the partial region (visual mode)\n---@return integer _ Returns a calculated comment mode\nfunction Op.blockwise(param, partial)\n    local is_x = #param.lines == 1 -- current-line blockwise\n    local lines = is_x and param.lines[1] or param.lines\n\n    local padding = U.is_fn(param.cfg.padding)\n\n    local scol, ecol = nil, nil\n    if is_x or partial then\n        scol, ecol = param.range.scol, param.range.ecol\n    end\n\n    -- If given mode is toggle then determine whether to comment or not\n    local cmode = param.cmode\n    if cmode == U.cmode.toggle then\n        local is_cmt = U.is_commented(param.lcs, param.rcs, padding, scol, ecol)(lines)\n        cmode = is_cmt and U.cmode.uncomment or U.cmode.comment\n    end\n\n    if cmode == U.cmode.uncomment then\n        lines = U.uncommenter(param.lcs, param.rcs, padding, scol, ecol)(lines)\n    else\n        lines = U.commenter(param.lcs, param.rcs, padding, scol, ecol)(lines)\n    end\n\n    if is_x then\n        A.nvim_set_current_line(lines)\n    else\n        A.nvim_buf_set_lines(0, param.range.srow - 1, param.range.erow, false, lines)\n    end\n\n    return cmode\nend\n\nreturn Op\n"
  },
  {
    "name": "/home/kdog3682/.config/nvim/lua/local-plugins/comment/lua/Comment/utils.lua",
    "size": 12965,
    "text": "---@mod comment.utils Utilities\n\nlocal F = require('Comment.ft')\nlocal A = vim.api\n\nlocal U = {}\n\n---Comment context\n---@class CommentCtx\n---@field ctype integer See |comment.utils.ctype|\n---@field cmode integer See |comment.utils.cmode|\n---@field cmotion integer See |comment.utils.cmotion|\n---@field range CommentRange\n\n---Range of the selection that needs to be commented\n---@class CommentRange\n---@field srow integer Starting row\n---@field scol integer Starting column\n---@field erow integer Ending row\n---@field ecol integer Ending column\n\n---Comment modes - Can be manual or computed via operator-mode\n---@class CommentMode\n---@field toggle integer Toggle action\n---@field comment integer Comment action\n---@field uncomment integer Uncomment action\n\n---An object containing comment modes\n---@type CommentMode\nU.cmode = {\n    toggle = 0,\n    comment = 1,\n    uncomment = 2,\n}\n\n---Comment types\n---@class CommentType\n---@field linewise integer Use linewise commentstring\n---@field blockwise integer Use blockwise commentstring\n\n---An object containing comment types\n---@type CommentType\nU.ctype = {\n    linewise = 1,\n    blockwise = 2,\n}\n\n---Comment motion types\n---@class CommentMotion\n---@field line integer Line motion (ie. 'gc2j')\n---@field char integer Character/left-right motion (ie. 'gc2w')\n---@field block integer Visual operator-pending motion\n---@field v integer Visual motion (ie. 'v3jgc')\n---@field V integer Visual-line motion (ie. 'V10kgc')\n\n---An object containing comment motions\n---@type CommentMotion\nU.cmotion = {\n    line = 1,\n    char = 2,\n    block = 3,\n    v = 4,\n    V = 5,\n}\n\n---@private\n---Check whether the line is empty\n---@param iter string|string[]\n---@return boolean\nfunction U.is_empty(iter)\n    return #iter == 0\nend\n\n---@private\n---Helper to get padding character\n---@param flag boolean\n---@return string string\nfunction U.get_pad(flag)\n    return flag and ' ' or ''\nend\n\n---@private\n---Helper to get padding pattern\n---@param flag boolean\n---@return string string\nfunction U.get_padpat(flag)\n    return flag and '%s?' or ''\nend\n\n---@private\n---Call a function if exists\n---@param fn unknown|fun(...):unknown Wanna be function\n---@return unknown\nfunction U.is_fn(fn, ...)\n    if type(fn) == 'function' then\n        return fn(...)\n    end\n    return fn\nend\n\n---@private\n---Check if the given line is ignored or not with the given pattern\n---@param ln string Line to be ignored\n---@param pat string Lua regex\n---@return boolean\nfunction U.ignore(ln, pat)\n    return pat and string.find(ln, pat) ~= nil\nend\n\n---Get region for line movement or visual selection\n---NOTE: Returns the current line region, if `opmode` is not given.\n---@param opmode? OpMotion\n---@return CommentRange\nfunction U.get_region(opmode)\n    if not opmode then\n        local row = unpack(A.nvim_win_get_cursor(0))\n        return { srow = row, scol = 0, erow = row, ecol = 0 }\n    end\n\n    local marks = string.match(opmode, '[vV\u0016]') and { '<', '>' } or { '[', ']' }\n    local sln, eln = A.nvim_buf_get_mark(0, marks[1]), A.nvim_buf_get_mark(0, marks[2])\n\n    return { srow = sln[1], scol = sln[2], erow = eln[1], ecol = eln[2] }\nend\n\n---Get lines from the current position to the given count\n---@param count integer Probably 'vim.v.count'\n---@return string[] #List of lines\n---@return CommentRange\nfunction U.get_count_lines(count)\n    local srow = unpack(A.nvim_win_get_cursor(0))\n    local erow = (srow + count) - 1\n    local lines = A.nvim_buf_get_lines(0, srow - 1, erow, false)\n\n    return lines, { srow = srow, scol = 0, erow = erow, ecol = 0 }\nend\n\n---Get lines from a NORMAL/VISUAL mode\n---@param range CommentRange\n---@return string[] #List of lines\nfunction U.get_lines(range)\n    -- If start and end is same, then just return the current line\n    if range.srow == range.erow then\n        return { A.nvim_get_current_line() }\n    end\n\n    return A.nvim_buf_get_lines(0, range.srow - 1, range.erow, false)\nend\n\n---Validates and unwraps the given commentstring\n---@param cstr string See 'commentstring'\n---@return string string Left side of the commentstring\n---@return string string Right side of the commentstring\nfunction U.unwrap_cstr(cstr)\n    local left, right = string.match(cstr, '(.*)%%s(.*)')\n\n    assert(\n        (left or right),\n        { msg = string.format('Invalid commentstring for %s! Read `:h commentstring` for help.', vim.bo.filetype) }\n    )\n\n    return vim.trim(left), vim.trim(right)\nend\n\n---Parses commentstring from the following places in the respective order\n---  1. pre_hook - commentstring returned from the function\n---  2. ft.lua - commentstring table bundled with the plugin\n---  3. commentstring - Neovim's native. See 'commentstring'\n---@param cfg CommentConfig\n---@param ctx CommentCtx\n---@return string string Left side of the commentstring\n---@return string string Right side of the commentstring\nfunction U.parse_cstr(cfg, ctx)\n    -- 1. We ask `pre_hook` for a commentstring\n    local inbuilt = U.is_fn(cfg.pre_hook, ctx)\n        -- 2. Calculate w/ the help of treesitter\n        or F.calculate(ctx)\n\n    assert(inbuilt or (ctx.ctype ~= U.ctype.blockwise), {\n        msg = vim.bo.filetype .. \" doesn't support block comments!\",\n    })\n\n    -- 3. Last resort to use native commentstring\n    return U.unwrap_cstr(inbuilt or vim.bo.commentstring)\nend\n\n---Returns a closure which is used to do comments\n---\n---If given {string[]} to the closure then it will do blockwise comment\n---else linewise comment will be done with the given {string}\n---@param left string Left side of the commentstring\n---@param right string Right side of the commentstring\n---@param padding boolean Is padding enabled?\n---@param scol? integer Starting column\n---@param ecol? integer Ending column\n---@param tabbed? boolean Using tab indentation\n---@return fun(line: string|string[]):string|string[]\nfunction U.commenter(left, right, padding, scol, ecol, tabbed)\n    local pad = U.get_pad(padding)\n    local ll = U.is_empty(left) and left or (left .. pad)\n    local rr = U.is_empty(right) and right or (pad .. right)\n    local empty = string.rep(tabbed and '\\t' or ' ', scol or 0) .. left .. right\n    local is_lw = scol and not ecol\n\n    return function(line)\n        ------------------\n        -- for linewise --\n        ------------------\n        if is_lw then\n            if U.is_empty(line) then\n                return empty\n            end\n            -- line == 0 -> start from 0 col\n            if scol == 0 then\n                return (ll .. line .. rr)\n            end\n            local first = string.sub(line --[[@as string]], 0, scol)\n            local last = string.sub(line --[[@as string]], scol + 1, -1)\n            return first .. ll .. last .. rr\n        end\n\n        -------------------\n        -- for blockwise --\n        -------------------\n        if type(line) == 'table' then\n            local first, last = line[1], line[#line]\n            -- If both columns are given then we can assume it's a partial block\n            if scol and ecol then\n                local sfirst = string.sub(first, 0, scol)\n                local slast = string.sub(first, scol + 1, -1)\n                local efirst = string.sub(last, 0, ecol + 1)\n                local elast = string.sub(last, ecol + 2, -1)\n                line[1] = sfirst .. ll .. slast\n                line[#line] = efirst .. rr .. elast\n            else\n                line[1] = U.is_empty(first) and left or string.gsub(first, '^(%s*)', '%1' .. vim.pesc(ll))\n                line[#line] = U.is_empty(last) and right or (last .. rr)\n            end\n            return line\n        end\n\n        --------------------------------\n        -- for current-line blockwise --\n        --------------------------------\n        -- SOURCE: https://github.com/numToStr/Comment.nvim/issues/224\n        if ecol > #line then\n            return ll .. line .. rr\n        end\n        local first = string.sub(line, 0, scol)\n        local mid = string.sub(line, scol + 1, ecol + 1)\n        local last = string.sub(line, ecol + 2, -1)\n        return first .. ll .. mid .. rr .. last\n    end\nend\n\n---Returns a closure which is used to uncomment a line\n---\n---If given {string[]} to the closure then it will block uncomment\n---else linewise uncomment will be done with the given {string}\n---@param left string Left side of the commentstring\n---@param right string Right side of the commentstring\n---@param padding boolean Is padding enabled?\n---@param scol? integer Starting column\n---@param ecol? integer Ending column\n---@return fun(line: string|string[]):string|string[]\nfunction U.uncommenter(left, right, padding, scol, ecol)\n    local pp, plen = U.get_padpat(padding), padding and 1 or 0\n    local left_len, right_len = #left + plen, #right + plen\n    local ll = U.is_empty(left) and left or vim.pesc(left) .. pp\n    local rr = U.is_empty(right) and right or pp .. vim.pesc(right)\n    local is_lw = not (scol and scol)\n    local pattern = is_lw and '^(%s*)' .. ll .. '(.-)' .. rr .. '$' or ''\n\n    return function(line)\n        -------------------\n        -- for blockwise --\n        -------------------\n        if type(line) == 'table' then\n            local first, last = line[1], line[#line]\n            -- If both columns are given then we can assume it's a partial block\n            if scol and ecol then\n                local sfirst = string.sub(first, 0, scol)\n                local slast = string.sub(first, scol + left_len + 1, -1)\n                local efirst = string.sub(last, 0, ecol - right_len + 1)\n                local elast = string.sub(last, ecol + 2, -1)\n                line[1] = sfirst .. slast\n                line[#line] = efirst .. elast\n            else\n                line[1] = string.gsub(first, '^(%s*)' .. ll, '%1')\n                line[#line] = string.gsub(last, rr .. '$', '')\n            end\n            return line\n        end\n\n        ------------------\n        -- for linewise --\n        ------------------\n        if is_lw then\n            local a, b, c = string.match(line, pattern)\n            -- When user tries to uncomment when there is nothing to uncomment. See #221\n            assert(a and b, { msg = 'Nothing to uncomment!' })\n            -- If there is nothing after LHS then just return ''\n            -- bcz the line previously (before comment) was empty\n            return U.is_empty(b) and b or a .. b .. (c or '')\n        end\n\n        --------------------------------\n        -- for current-line blockwise --\n        --------------------------------\n        -- SOURCE: https://github.com/numToStr/Comment.nvim/issues/224\n        if ecol > #line then\n            return string.sub(line, scol + left_len + 1, #line - right_len)\n        end\n        local first = string.sub(line, 0, scol)\n        local mid = string.sub(line, scol + left_len + 1, ecol - right_len + 1)\n        local last = string.sub(line, ecol + 2, -1)\n        return first .. mid .. last\n    end\nend\n\n---Check if the given string is commented or not\n---\n---If given {string[]} to the closure, it will check the first and last line\n---with LHS and RHS of commentstring respectively else it will check the given\n---line with LHS and RHS (if given) of the commenstring\n---@param left string Left side of the commentstring\n---@param right string Right side of the commentstring\n---@param padding boolean Is padding enabled?\n---@param scol? integer Starting column\n---@param ecol? integer Ending column\n---@return fun(line: string|string[]):boolean\nfunction U.is_commented(left, right, padding, scol, ecol)\n    local pp = U.get_padpat(padding)\n    local ll = U.is_empty(left) and left or '^%s*' .. vim.pesc(left) .. pp\n    local rr = U.is_empty(right) and right or pp .. vim.pesc(right) .. '$'\n    local pattern = ll .. '.-' .. rr\n    local is_full = scol == nil or ecol == nil\n\n    return function(line)\n        -------------------\n        -- for blockwise --\n        -------------------\n        if type(line) == 'table' then\n            local first, last = line[1], line[#line]\n            if is_full then\n                return (string.find(first, ll) and string.find(last, rr)) ~= nil\n            end\n            return (string.find(string.sub(first, scol + 1, -1), ll) and string.find(string.sub(last, 0, ecol + 1), rr))\n                ~= nil\n        end\n\n        ------------------\n        -- for linewise --\n        ------------------\n        if is_full then\n            return string.find(line, pattern) ~= nil\n        end\n\n        --------------------------------\n        -- for current-line blockwise --\n        --------------------------------\n        -- SOURCE: https://github.com/numToStr/Comment.nvim/issues/224\n        return string.find(string.sub(line, scol + 1, (ecol > #line and #line or ecol + 1)), pattern) ~= nil\n    end\nend\n\n---@private\n---Error handler\n---@param ... unknown\nfunction U.catch(fn, ...)\n    xpcall(fn, function(err)\n        vim.notify(string.format('[Comment.nvim] %s', err.msg), vim.log.levels.WARN)\n    end, ...)\nend\n\nreturn U\n"
  }
]