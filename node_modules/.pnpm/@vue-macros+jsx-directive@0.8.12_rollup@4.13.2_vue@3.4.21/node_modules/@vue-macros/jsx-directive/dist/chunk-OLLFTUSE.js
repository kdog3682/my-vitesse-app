"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }// src/core/index.ts








var _common = require('@vue-macros/common');

// src/core/v-if.ts
function transformVIf(nodes, s, offset, version) {
  nodes.forEach(({ node, attribute, parent }, index) => {
    const hasScope = ["JSXElement", "JSXFragment"].includes(`${_optionalChain([parent, 'optionalAccess', _2 => _2.type])}`);
    if (["v-if", "v-else-if"].includes(`${attribute.name.name}`)) {
      if (attribute.value)
        s.appendLeft(
          node.start + offset,
          `${attribute.name.name === "v-if" && hasScope ? "{" : " "}(${s.slice(
            attribute.value.start + offset + 1,
            attribute.value.end + offset - 1
          )}) ? `
        );
      s.appendRight(
        node.end + offset,
        `${_optionalChain([nodes, 'access', _3 => _3[index + 1], 'optionalAccess', _4 => _4.attribute, 'access', _5 => _5.name, 'access', _6 => _6.name])}`.startsWith("v-else") ? " :" : ` : null${hasScope ? "}" : ""}`
      );
    } else if (attribute.name.name === "v-else") {
      s.appendRight(node.end + offset, hasScope ? "}" : "");
    }
    const isTemplate = node.type === "JSXElement" && node.openingElement.name.type === "JSXIdentifier" && node.openingElement.name.name === "template";
    if (isTemplate && node.closingElement) {
      const content = version < 3 ? "span" : "";
      s.overwriteNode(node.openingElement.name, content, { offset });
      s.overwriteNode(node.closingElement.name, content, { offset });
    }
    s.remove(attribute.start + offset - 1, attribute.end + offset);
  });
}

// src/core/v-for.ts




function resolveVFor(attribute, {
  s,
  offset,
  version,
  vMemoAttribute
}) {
  if (attribute.value) {
    let item, index, objectIndex, list;
    if (attribute.value.type === "JSXExpressionContainer" && attribute.value.expression.type === "BinaryExpression") {
      if (attribute.value.expression.left.type === "SequenceExpression") {
        const expressions = attribute.value.expression.left.expressions;
        item = expressions[0] ? s.sliceNode(expressions[0], { offset }) : "";
        index = expressions[1] ? s.sliceNode(expressions[1], { offset }) : "";
        objectIndex = expressions[2] ? s.sliceNode(expressions[2], { offset }) : "";
      } else {
        item = s.sliceNode(attribute.value.expression.left, { offset });
      }
      list = s.sliceNode(attribute.value.expression.right, { offset });
    }
    if (item && list) {
      if (vMemoAttribute) {
        index ??= `${_common.HELPER_PREFIX}index`;
      }
      const renderList = version < 3 ? "Array.from" : _common.importHelperFn.call(void 0, s, offset, "renderList", "vue");
      return `${renderList}(${list}, (${item}${index ? `, ${index}` : ""}${objectIndex ? `, ${objectIndex}` : ""}) => `;
    }
  }
  return "";
}
function transformVFor(nodes, s, offset, version) {
  if (nodes.length === 0)
    return;
  nodes.forEach(({ node, attribute, parent, vMemoAttribute }) => {
    const hasScope = ["JSXElement", "JSXFragment"].includes(`${_optionalChain([parent, 'optionalAccess', _7 => _7.type])}`);
    s.appendLeft(
      node.start + offset,
      `${hasScope ? "{" : ""}${resolveVFor(attribute, { s, offset, version, vMemoAttribute })}`
    );
    const isTemplate = node.type === "JSXElement" && node.openingElement.name.type === "JSXIdentifier" && node.openingElement.name.name === "template";
    if (isTemplate && node.closingElement) {
      const content = version < 3 ? "span" : "";
      s.overwriteNode(node.openingElement.name, content, { offset });
      s.overwriteNode(node.closingElement.name, content, { offset });
    }
    s.prependRight(node.end + offset, `)${hasScope ? "}" : ""}`);
    s.remove(attribute.start + offset - 1, attribute.end + offset);
  });
}

// src/core/v-memo.ts




function transformVMemo(nodes, s, offset) {
  if (nodes.length === 0)
    return;
  const withMemo = _common.importHelperFn.call(void 0, s, offset, "withMemo", "vue");
  s.prependRight(offset, `const ${_common.HELPER_PREFIX}cache = [];`);
  nodes.forEach(({ node, attribute, parent, vForAttribute }, nodeIndex) => {
    const hasScope = ["JSXElement", "JSXFragment"].includes(`${_optionalChain([parent, 'optionalAccess', _8 => _8.type])}`);
    s.appendLeft(
      node.start + offset,
      `${hasScope ? "{" : ""}${withMemo}(${attribute.value ? s.slice(
        attribute.value.start + offset + 1,
        attribute.value.end + offset - 1
      ) : `[]`}, () => `
    );
    let index = `${nodeIndex}`;
    let cache = `${_common.HELPER_PREFIX}cache`;
    let vForIndex = `${_common.HELPER_PREFIX}index`;
    if (_optionalChain([vForAttribute, 'optionalAccess', _9 => _9.value, 'optionalAccess', _10 => _10.type]) === "JSXExpressionContainer") {
      if (vForAttribute.value.expression.type === "BinaryExpression" && vForAttribute.value.expression.left.type === "SequenceExpression" && vForAttribute.value.expression.left.expressions[1].type === "Identifier")
        vForIndex = vForAttribute.value.expression.left.expressions[1].name;
      cache += `[${index}]`;
      s.appendRight(offset, `${cache} = [];`);
      index += ` + ${vForIndex} + 1`;
    }
    s.prependRight(
      node.end + offset,
      `, ${cache}, ${index})${hasScope ? "}" : ""}`
    );
    s.remove(attribute.start + offset - 1, attribute.end + offset);
  });
}

// src/core/v-html.ts
function transformVHtml(nodes, s, offset, version) {
  nodes.forEach(({ attribute }) => {
    s.overwriteNode(
      attribute.name,
      version < 3 ? "domPropsInnerHTML" : "innerHTML",
      { offset }
    );
  });
}

// src/core/v-model.ts

function transformVModel(attribute, s, offset) {
  if (attribute.name.type === "JSXNamespacedName" && _optionalChain([attribute, 'access', _11 => _11.value, 'optionalAccess', _12 => _12.type]) === "JSXExpressionContainer") {
    const matched = attribute.name.name.name.match(/^\$(.*)\$(?:_(.*))?/);
    if (!matched)
      return;
    let [, argument, modifiers] = matched;
    const value = s.sliceNode(attribute.value.expression, { offset });
    argument = `${_common.importHelperFn.call(void 0, s, offset, "unref")}(${argument})`;
    modifiers = modifiers ? `, [${argument} + "Modifiers"]: { ${modifiers.split("_").map((key) => `${key}: true`).join(", ")} }` : "";
    s.overwriteNode(
      attribute,
      `{...{[${argument}]: ${value}, ["onUpdate:" + ${argument}]: $event => ${value} = $event${modifiers}}}`,
      { offset }
    );
  }
}

// src/core/v-slot.ts

function transformVSlot(nodeMap, s, offset, version) {
  Array.from(nodeMap).reverse().forEach(([node, { attributeMap, vSlotAttribute }]) => {
    const result = [` ${version < 3 ? "scopedSlots" : "v-slots"}={{`];
    const attributes = Array.from(attributeMap);
    attributes.forEach(
      ([attribute, { children, vIfAttribute, vForAttribute }], index) => {
        if (!attribute)
          return;
        if (vIfAttribute) {
          if ("v-if" === vIfAttribute.name.name) {
            result.push("...");
          }
          if (["v-if", "v-else-if"].includes(`${vIfAttribute.name.name}`) && _optionalChain([vIfAttribute, 'access', _13 => _13.value, 'optionalAccess', _14 => _14.type]) === "JSXExpressionContainer") {
            result.push(
              `(${s.sliceNode(vIfAttribute.value.expression, {
                offset
              })}) ? {`
            );
          } else if ("v-else" === vIfAttribute.name.name) {
            result.push("{");
          }
        }
        if (vForAttribute) {
          result.push(
            "...Object.fromEntries(",
            resolveVFor(vForAttribute, { s, offset, version }),
            "(["
          );
        }
        let isDynamic = false;
        let attributeName = attribute.name.type === "JSXNamespacedName" ? attribute.name.name.name : "default";
        attributeName = attributeName.replace(/\$(.*)\$/, (_, $1) => {
          isDynamic = true;
          return $1;
        });
        result.push(
          isDynamic ? `[${_common.importHelperFn.call(void 0, s, offset, "unref")}(${attributeName})]` : `'${attributeName}'`,
          vForAttribute ? ", " : ": ",
          "(",
          attribute.value && attribute.value.type === "JSXExpressionContainer" ? s.sliceNode(attribute.value.expression, { offset }) : "",
          ") => ",
          version < 3 ? "<span>" : "<>",
          children.map((child) => {
            const str = s.sliceNode(
              child.type === "JSXElement" && s.sliceNode(child.openingElement.name, { offset }) === "template" ? child.children : child,
              { offset }
            );
            s.removeNode(child, { offset });
            return str;
          }).join("") || " ",
          version < 3 ? "</span>," : "</>,"
        );
        if (vIfAttribute) {
          if (["v-if", "v-else-if"].includes(`${vIfAttribute.name.name}`)) {
            const nextIndex = index + (_optionalChain([attributes, 'access', _15 => _15[index + 1], 'optionalAccess', _16 => _16[0]]) ? 1 : 2);
            result.push(
              "}",
              `${_optionalChain([attributes, 'access', _17 => _17[nextIndex], 'optionalAccess', _18 => _18[1], 'access', _19 => _19.vIfAttribute, 'optionalAccess', _20 => _20.name, 'access', _21 => _21.name])}`.startsWith(
                "v-else"
              ) ? " : " : " : null,"
            );
          } else if ("v-else" === vIfAttribute.name.name) {
            result.push("},");
          }
        }
        if (vForAttribute) {
          result.push("]))),");
        }
      }
    );
    if (attributeMap.has(null)) {
      result.push(`default: () => ${version < 3 ? "<span>" : "<>"}`);
    } else {
      result.push("}}");
    }
    if (vSlotAttribute) {
      s.overwriteNode(vSlotAttribute, result.join(""), { offset });
    } else if (_optionalChain([node, 'optionalAccess', _22 => _22.type]) === "JSXElement") {
      s.overwrite(
        node.openingElement.end + offset - 1,
        node.openingElement.end + offset,
        result.join("")
      );
      s.appendLeft(
        node.closingElement.start + offset,
        attributeMap.has(null) ? `${version < 3 ? "</span>" : "</>"}}}>` : ">"
      );
    }
  });
}

// src/core/v-on.ts




function transformVOn(nodes, s, offset, version) {
  if (nodes.length > 0 && version >= 3)
    s.prependRight(
      offset,
      `const ${_common.HELPER_PREFIX}transformVOn = (obj) => Object.entries(obj).reduce((res, [key, value]) => (res['on' + key[0].toUpperCase() + key.slice(1)] = value, res), {});`
    );
  nodes.forEach(({ attribute }) => {
    if (version < 3) {
      s.remove(attribute.start + offset, attribute.start + offset + 2);
      return;
    }
    s.overwriteNode(
      attribute,
      `{...${_common.HELPER_PREFIX}transformVOn(${s.slice(
        attribute.value.start + offset + 1,
        attribute.value.end + offset - 1
      )})}`,
      { offset }
    );
  });
}
function transformVOnWithModifiers(nodes, s, offset, version) {
  let withModifiers;
  nodes.forEach(({ attribute }) => {
    const attributeName = attribute.name.name.toString();
    if (version < 3) {
      s.overwrite(
        attribute.name.start + offset,
        attribute.name.start + 3 + offset,
        `v-on:${attributeName[2].toLowerCase()}`
      );
      if (!attribute.value)
        s.appendRight(attribute.name.end + offset, "={() => {}}");
      return;
    }
    if (!withModifiers)
      withModifiers = _common.importHelperFn.call(void 0, s, offset, "withModifiers", "vue");
    let [name, ...modifiers] = attributeName.split("_");
    modifiers = modifiers.filter((modifier) => {
      if (modifier === "capture") {
        s.appendRight(
          attribute.name.end + offset,
          modifier[0].toUpperCase() + modifier.slice(1)
        );
        return false;
      } else {
        return true;
      }
    });
    s.remove(
      attribute.name.start + name.length + offset,
      attribute.name.end + offset
    );
    if (_optionalChain([attribute, 'access', _23 => _23.value, 'optionalAccess', _24 => _24.type]) === "JSXExpressionContainer") {
      s.appendRight(
        attribute.value.expression.start + offset,
        `${withModifiers}(`
      );
      s.appendLeft(
        attribute.value.expression.end + offset,
        `,[${modifiers.map((modifier) => `'${modifier}'`).join(",")}])`
      );
    } else {
      s.appendRight(
        attribute.name.end + offset,
        `={${withModifiers}(() => {}, [${modifiers.map((modifier) => `'${modifier}'`).join(",")}])}`
      );
    }
  });
}

// src/core/index.ts
function transformJsxDirective(code, id, version) {
  const lang = _common.getLang.call(void 0, id);
  let asts = [];
  if (lang === "vue" || _common.REGEX_SETUP_SFC.test(id)) {
    const { scriptSetup, getSetupAst, script, getScriptAst } = _common.parseSFC.call(void 0, 
      code,
      id
    );
    if (script) {
      asts.push({ ast: getScriptAst(), offset: script.loc.start.offset });
    }
    if (scriptSetup) {
      asts.push({ ast: getSetupAst(), offset: scriptSetup.loc.start.offset });
    }
  } else if (["jsx", "tsx"].includes(lang)) {
    asts = [{ ast: _common.babelParse.call(void 0, code, lang), offset: 0 }];
  } else {
    return;
  }
  const s = new (0, _common.MagicString)(code);
  for (const { ast, offset } of asts) {
    const vIfMap = /* @__PURE__ */ new Map();
    const vForNodes = [];
    const vMemoNodes = [];
    const vHtmlNodes = [];
    const vSlotMap = /* @__PURE__ */ new Map();
    const vOnNodes = [];
    const vOnWithModifiers = [];
    _common.walkAST.call(void 0, ast, {
      enter(node, parent) {
        if (node.type !== "JSXElement")
          return;
        const tagName = s.sliceNode(node.openingElement.name, {
          offset
        });
        let vIfAttribute;
        let vForAttribute;
        let vMemoAttribute;
        let vSlotAttribute;
        for (const attribute of node.openingElement.attributes) {
          if (attribute.type !== "JSXAttribute")
            continue;
          if (["v-if", "v-else-if", "v-else"].includes(`${attribute.name.name}`)) {
            vIfAttribute = attribute;
          } else if (attribute.name.name === "v-for") {
            vForAttribute = attribute;
          } else if (["v-memo", "v-once"].includes(`${attribute.name.name}`)) {
            vMemoAttribute = attribute;
          } else if (attribute.name.name === "v-html") {
            vHtmlNodes.push({
              node,
              attribute
            });
          } else if ((attribute.name.type === "JSXNamespacedName" ? attribute.name.namespace : attribute.name).name === "v-slot") {
            vSlotAttribute = attribute;
          } else if (attribute.name.name === "v-on") {
            vOnNodes.push({
              node,
              attribute
            });
          } else if (/^on[A-Z]\S*_\S+/.test(`${attribute.name.name}`)) {
            vOnWithModifiers.push({
              node,
              attribute
            });
          } else if (attribute.name.type === "JSXNamespacedName" && attribute.name.namespace.name === "v-model") {
            transformVModel(attribute, s, offset);
          }
        }
        if (!(vSlotAttribute && tagName === "template")) {
          if (vIfAttribute) {
            vIfMap.get(parent) || vIfMap.set(parent, []);
            vIfMap.get(parent).push({
              node,
              attribute: vIfAttribute,
              parent
            });
          }
          if (vForAttribute) {
            vForNodes.push({
              node,
              attribute: vForAttribute,
              parent: vIfAttribute ? void 0 : parent,
              vMemoAttribute
            });
          }
        }
        if (vMemoAttribute) {
          vMemoNodes.push({
            node,
            attribute: vMemoAttribute,
            parent: vForAttribute || vIfAttribute ? void 0 : parent,
            vForAttribute
          });
        }
        if (vSlotAttribute) {
          const slotNode = tagName === "template" ? parent : node;
          if (_optionalChain([slotNode, 'optionalAccess', _25 => _25.type]) !== "JSXElement")
            return;
          const attributeMap = _optionalChain([vSlotMap, 'access', _26 => _26.get, 'call', _27 => _27(slotNode), 'optionalAccess', _28 => _28.attributeMap]) || vSlotMap.set(slotNode, {
            vSlotAttribute: tagName !== "template" ? vSlotAttribute : void 0,
            attributeMap: /* @__PURE__ */ new Map()
          }).get(slotNode).attributeMap;
          const children = _optionalChain([attributeMap, 'access', _29 => _29.get, 'call', _30 => _30(vSlotAttribute), 'optionalAccess', _31 => _31.children]) || attributeMap.set(vSlotAttribute, {
            children: [],
            ...tagName === "template" ? {
              vIfAttribute,
              vForAttribute
            } : {}
          }).get(vSlotAttribute).children;
          if (slotNode === parent) {
            children.push(node);
            if (attributeMap.get(null))
              return;
            for (const child of parent.children) {
              if (child.type === "JSXElement" && s.sliceNode(child.openingElement.name, { offset }) === "template" || child.type === "JSXText" && !s.sliceNode(child, { offset }).trim())
                continue;
              const defaultNodes = _optionalChain([attributeMap, 'access', _32 => _32.get, 'call', _33 => _33(null), 'optionalAccess', _34 => _34.children]) || attributeMap.set(null, { children: [] }).get(null).children;
              defaultNodes.push(child);
            }
          } else {
            children.push(...node.children);
          }
        }
      }
    });
    vIfMap.forEach((nodes) => transformVIf(nodes, s, offset, version));
    transformVFor(vForNodes, s, offset, version);
    version >= 3.2 && transformVMemo(vMemoNodes, s, offset);
    transformVHtml(vHtmlNodes, s, offset, version);
    transformVOn(vOnNodes, s, offset, version);
    transformVOnWithModifiers(vOnWithModifiers, s, offset, version);
    transformVSlot(vSlotMap, s, offset, version);
  }
  return _common.generateTransform.call(void 0, s, id);
}



exports.transformJsxDirective = transformJsxDirective;
