// src/core/index.ts
import {
  MagicString,
  REGEX_SETUP_SFC,
  babelParse,
  generateTransform,
  getLang,
  parseSFC,
  walkAST
} from "@vue-macros/common";

// src/core/v-if.ts
function transformVIf(nodes, s, offset, version) {
  nodes.forEach(({ node, attribute, parent }, index) => {
    const hasScope = ["JSXElement", "JSXFragment"].includes(`${parent?.type}`);
    if (["v-if", "v-else-if"].includes(`${attribute.name.name}`)) {
      if (attribute.value)
        s.appendLeft(
          node.start + offset,
          `${attribute.name.name === "v-if" && hasScope ? "{" : " "}(${s.slice(
            attribute.value.start + offset + 1,
            attribute.value.end + offset - 1
          )}) ? `
        );
      s.appendRight(
        node.end + offset,
        `${nodes[index + 1]?.attribute.name.name}`.startsWith("v-else") ? " :" : ` : null${hasScope ? "}" : ""}`
      );
    } else if (attribute.name.name === "v-else") {
      s.appendRight(node.end + offset, hasScope ? "}" : "");
    }
    const isTemplate = node.type === "JSXElement" && node.openingElement.name.type === "JSXIdentifier" && node.openingElement.name.name === "template";
    if (isTemplate && node.closingElement) {
      const content = version < 3 ? "span" : "";
      s.overwriteNode(node.openingElement.name, content, { offset });
      s.overwriteNode(node.closingElement.name, content, { offset });
    }
    s.remove(attribute.start + offset - 1, attribute.end + offset);
  });
}

// src/core/v-for.ts
import {
  HELPER_PREFIX,
  importHelperFn
} from "@vue-macros/common";
function resolveVFor(attribute, {
  s,
  offset,
  version,
  vMemoAttribute
}) {
  if (attribute.value) {
    let item, index, objectIndex, list;
    if (attribute.value.type === "JSXExpressionContainer" && attribute.value.expression.type === "BinaryExpression") {
      if (attribute.value.expression.left.type === "SequenceExpression") {
        const expressions = attribute.value.expression.left.expressions;
        item = expressions[0] ? s.sliceNode(expressions[0], { offset }) : "";
        index = expressions[1] ? s.sliceNode(expressions[1], { offset }) : "";
        objectIndex = expressions[2] ? s.sliceNode(expressions[2], { offset }) : "";
      } else {
        item = s.sliceNode(attribute.value.expression.left, { offset });
      }
      list = s.sliceNode(attribute.value.expression.right, { offset });
    }
    if (item && list) {
      if (vMemoAttribute) {
        index ??= `${HELPER_PREFIX}index`;
      }
      const renderList = version < 3 ? "Array.from" : importHelperFn(s, offset, "renderList", "vue");
      return `${renderList}(${list}, (${item}${index ? `, ${index}` : ""}${objectIndex ? `, ${objectIndex}` : ""}) => `;
    }
  }
  return "";
}
function transformVFor(nodes, s, offset, version) {
  if (nodes.length === 0)
    return;
  nodes.forEach(({ node, attribute, parent, vMemoAttribute }) => {
    const hasScope = ["JSXElement", "JSXFragment"].includes(`${parent?.type}`);
    s.appendLeft(
      node.start + offset,
      `${hasScope ? "{" : ""}${resolveVFor(attribute, { s, offset, version, vMemoAttribute })}`
    );
    const isTemplate = node.type === "JSXElement" && node.openingElement.name.type === "JSXIdentifier" && node.openingElement.name.name === "template";
    if (isTemplate && node.closingElement) {
      const content = version < 3 ? "span" : "";
      s.overwriteNode(node.openingElement.name, content, { offset });
      s.overwriteNode(node.closingElement.name, content, { offset });
    }
    s.prependRight(node.end + offset, `)${hasScope ? "}" : ""}`);
    s.remove(attribute.start + offset - 1, attribute.end + offset);
  });
}

// src/core/v-memo.ts
import {
  HELPER_PREFIX as HELPER_PREFIX2,
  importHelperFn as importHelperFn2
} from "@vue-macros/common";
function transformVMemo(nodes, s, offset) {
  if (nodes.length === 0)
    return;
  const withMemo = importHelperFn2(s, offset, "withMemo", "vue");
  s.prependRight(offset, `const ${HELPER_PREFIX2}cache = [];`);
  nodes.forEach(({ node, attribute, parent, vForAttribute }, nodeIndex) => {
    const hasScope = ["JSXElement", "JSXFragment"].includes(`${parent?.type}`);
    s.appendLeft(
      node.start + offset,
      `${hasScope ? "{" : ""}${withMemo}(${attribute.value ? s.slice(
        attribute.value.start + offset + 1,
        attribute.value.end + offset - 1
      ) : `[]`}, () => `
    );
    let index = `${nodeIndex}`;
    let cache = `${HELPER_PREFIX2}cache`;
    let vForIndex = `${HELPER_PREFIX2}index`;
    if (vForAttribute?.value?.type === "JSXExpressionContainer") {
      if (vForAttribute.value.expression.type === "BinaryExpression" && vForAttribute.value.expression.left.type === "SequenceExpression" && vForAttribute.value.expression.left.expressions[1].type === "Identifier")
        vForIndex = vForAttribute.value.expression.left.expressions[1].name;
      cache += `[${index}]`;
      s.appendRight(offset, `${cache} = [];`);
      index += ` + ${vForIndex} + 1`;
    }
    s.prependRight(
      node.end + offset,
      `, ${cache}, ${index})${hasScope ? "}" : ""}`
    );
    s.remove(attribute.start + offset - 1, attribute.end + offset);
  });
}

// src/core/v-html.ts
function transformVHtml(nodes, s, offset, version) {
  nodes.forEach(({ attribute }) => {
    s.overwriteNode(
      attribute.name,
      version < 3 ? "domPropsInnerHTML" : "innerHTML",
      { offset }
    );
  });
}

// src/core/v-model.ts
import { importHelperFn as importHelperFn3 } from "@vue-macros/common";
function transformVModel(attribute, s, offset) {
  if (attribute.name.type === "JSXNamespacedName" && attribute.value?.type === "JSXExpressionContainer") {
    const matched = attribute.name.name.name.match(/^\$(.*)\$(?:_(.*))?/);
    if (!matched)
      return;
    let [, argument, modifiers] = matched;
    const value = s.sliceNode(attribute.value.expression, { offset });
    argument = `${importHelperFn3(s, offset, "unref")}(${argument})`;
    modifiers = modifiers ? `, [${argument} + "Modifiers"]: { ${modifiers.split("_").map((key) => `${key}: true`).join(", ")} }` : "";
    s.overwriteNode(
      attribute,
      `{...{[${argument}]: ${value}, ["onUpdate:" + ${argument}]: $event => ${value} = $event${modifiers}}}`,
      { offset }
    );
  }
}

// src/core/v-slot.ts
import { importHelperFn as importHelperFn4 } from "@vue-macros/common";
function transformVSlot(nodeMap, s, offset, version) {
  Array.from(nodeMap).reverse().forEach(([node, { attributeMap, vSlotAttribute }]) => {
    const result = [` ${version < 3 ? "scopedSlots" : "v-slots"}={{`];
    const attributes = Array.from(attributeMap);
    attributes.forEach(
      ([attribute, { children, vIfAttribute, vForAttribute }], index) => {
        if (!attribute)
          return;
        if (vIfAttribute) {
          if ("v-if" === vIfAttribute.name.name) {
            result.push("...");
          }
          if (["v-if", "v-else-if"].includes(`${vIfAttribute.name.name}`) && vIfAttribute.value?.type === "JSXExpressionContainer") {
            result.push(
              `(${s.sliceNode(vIfAttribute.value.expression, {
                offset
              })}) ? {`
            );
          } else if ("v-else" === vIfAttribute.name.name) {
            result.push("{");
          }
        }
        if (vForAttribute) {
          result.push(
            "...Object.fromEntries(",
            resolveVFor(vForAttribute, { s, offset, version }),
            "(["
          );
        }
        let isDynamic = false;
        let attributeName = attribute.name.type === "JSXNamespacedName" ? attribute.name.name.name : "default";
        attributeName = attributeName.replace(/\$(.*)\$/, (_, $1) => {
          isDynamic = true;
          return $1;
        });
        result.push(
          isDynamic ? `[${importHelperFn4(s, offset, "unref")}(${attributeName})]` : `'${attributeName}'`,
          vForAttribute ? ", " : ": ",
          "(",
          attribute.value && attribute.value.type === "JSXExpressionContainer" ? s.sliceNode(attribute.value.expression, { offset }) : "",
          ") => ",
          version < 3 ? "<span>" : "<>",
          children.map((child) => {
            const str = s.sliceNode(
              child.type === "JSXElement" && s.sliceNode(child.openingElement.name, { offset }) === "template" ? child.children : child,
              { offset }
            );
            s.removeNode(child, { offset });
            return str;
          }).join("") || " ",
          version < 3 ? "</span>," : "</>,"
        );
        if (vIfAttribute) {
          if (["v-if", "v-else-if"].includes(`${vIfAttribute.name.name}`)) {
            const nextIndex = index + (attributes[index + 1]?.[0] ? 1 : 2);
            result.push(
              "}",
              `${attributes[nextIndex]?.[1].vIfAttribute?.name.name}`.startsWith(
                "v-else"
              ) ? " : " : " : null,"
            );
          } else if ("v-else" === vIfAttribute.name.name) {
            result.push("},");
          }
        }
        if (vForAttribute) {
          result.push("]))),");
        }
      }
    );
    if (attributeMap.has(null)) {
      result.push(`default: () => ${version < 3 ? "<span>" : "<>"}`);
    } else {
      result.push("}}");
    }
    if (vSlotAttribute) {
      s.overwriteNode(vSlotAttribute, result.join(""), { offset });
    } else if (node?.type === "JSXElement") {
      s.overwrite(
        node.openingElement.end + offset - 1,
        node.openingElement.end + offset,
        result.join("")
      );
      s.appendLeft(
        node.closingElement.start + offset,
        attributeMap.has(null) ? `${version < 3 ? "</span>" : "</>"}}}>` : ">"
      );
    }
  });
}

// src/core/v-on.ts
import {
  HELPER_PREFIX as HELPER_PREFIX3,
  importHelperFn as importHelperFn5
} from "@vue-macros/common";
function transformVOn(nodes, s, offset, version) {
  if (nodes.length > 0 && version >= 3)
    s.prependRight(
      offset,
      `const ${HELPER_PREFIX3}transformVOn = (obj) => Object.entries(obj).reduce((res, [key, value]) => (res['on' + key[0].toUpperCase() + key.slice(1)] = value, res), {});`
    );
  nodes.forEach(({ attribute }) => {
    if (version < 3) {
      s.remove(attribute.start + offset, attribute.start + offset + 2);
      return;
    }
    s.overwriteNode(
      attribute,
      `{...${HELPER_PREFIX3}transformVOn(${s.slice(
        attribute.value.start + offset + 1,
        attribute.value.end + offset - 1
      )})}`,
      { offset }
    );
  });
}
function transformVOnWithModifiers(nodes, s, offset, version) {
  let withModifiers;
  nodes.forEach(({ attribute }) => {
    const attributeName = attribute.name.name.toString();
    if (version < 3) {
      s.overwrite(
        attribute.name.start + offset,
        attribute.name.start + 3 + offset,
        `v-on:${attributeName[2].toLowerCase()}`
      );
      if (!attribute.value)
        s.appendRight(attribute.name.end + offset, "={() => {}}");
      return;
    }
    if (!withModifiers)
      withModifiers = importHelperFn5(s, offset, "withModifiers", "vue");
    let [name, ...modifiers] = attributeName.split("_");
    modifiers = modifiers.filter((modifier) => {
      if (modifier === "capture") {
        s.appendRight(
          attribute.name.end + offset,
          modifier[0].toUpperCase() + modifier.slice(1)
        );
        return false;
      } else {
        return true;
      }
    });
    s.remove(
      attribute.name.start + name.length + offset,
      attribute.name.end + offset
    );
    if (attribute.value?.type === "JSXExpressionContainer") {
      s.appendRight(
        attribute.value.expression.start + offset,
        `${withModifiers}(`
      );
      s.appendLeft(
        attribute.value.expression.end + offset,
        `,[${modifiers.map((modifier) => `'${modifier}'`).join(",")}])`
      );
    } else {
      s.appendRight(
        attribute.name.end + offset,
        `={${withModifiers}(() => {}, [${modifiers.map((modifier) => `'${modifier}'`).join(",")}])}`
      );
    }
  });
}

// src/core/index.ts
function transformJsxDirective(code, id, version) {
  const lang = getLang(id);
  let asts = [];
  if (lang === "vue" || REGEX_SETUP_SFC.test(id)) {
    const { scriptSetup, getSetupAst, script, getScriptAst } = parseSFC(
      code,
      id
    );
    if (script) {
      asts.push({ ast: getScriptAst(), offset: script.loc.start.offset });
    }
    if (scriptSetup) {
      asts.push({ ast: getSetupAst(), offset: scriptSetup.loc.start.offset });
    }
  } else if (["jsx", "tsx"].includes(lang)) {
    asts = [{ ast: babelParse(code, lang), offset: 0 }];
  } else {
    return;
  }
  const s = new MagicString(code);
  for (const { ast, offset } of asts) {
    const vIfMap = /* @__PURE__ */ new Map();
    const vForNodes = [];
    const vMemoNodes = [];
    const vHtmlNodes = [];
    const vSlotMap = /* @__PURE__ */ new Map();
    const vOnNodes = [];
    const vOnWithModifiers = [];
    walkAST(ast, {
      enter(node, parent) {
        if (node.type !== "JSXElement")
          return;
        const tagName = s.sliceNode(node.openingElement.name, {
          offset
        });
        let vIfAttribute;
        let vForAttribute;
        let vMemoAttribute;
        let vSlotAttribute;
        for (const attribute of node.openingElement.attributes) {
          if (attribute.type !== "JSXAttribute")
            continue;
          if (["v-if", "v-else-if", "v-else"].includes(`${attribute.name.name}`)) {
            vIfAttribute = attribute;
          } else if (attribute.name.name === "v-for") {
            vForAttribute = attribute;
          } else if (["v-memo", "v-once"].includes(`${attribute.name.name}`)) {
            vMemoAttribute = attribute;
          } else if (attribute.name.name === "v-html") {
            vHtmlNodes.push({
              node,
              attribute
            });
          } else if ((attribute.name.type === "JSXNamespacedName" ? attribute.name.namespace : attribute.name).name === "v-slot") {
            vSlotAttribute = attribute;
          } else if (attribute.name.name === "v-on") {
            vOnNodes.push({
              node,
              attribute
            });
          } else if (/^on[A-Z]\S*_\S+/.test(`${attribute.name.name}`)) {
            vOnWithModifiers.push({
              node,
              attribute
            });
          } else if (attribute.name.type === "JSXNamespacedName" && attribute.name.namespace.name === "v-model") {
            transformVModel(attribute, s, offset);
          }
        }
        if (!(vSlotAttribute && tagName === "template")) {
          if (vIfAttribute) {
            vIfMap.get(parent) || vIfMap.set(parent, []);
            vIfMap.get(parent).push({
              node,
              attribute: vIfAttribute,
              parent
            });
          }
          if (vForAttribute) {
            vForNodes.push({
              node,
              attribute: vForAttribute,
              parent: vIfAttribute ? void 0 : parent,
              vMemoAttribute
            });
          }
        }
        if (vMemoAttribute) {
          vMemoNodes.push({
            node,
            attribute: vMemoAttribute,
            parent: vForAttribute || vIfAttribute ? void 0 : parent,
            vForAttribute
          });
        }
        if (vSlotAttribute) {
          const slotNode = tagName === "template" ? parent : node;
          if (slotNode?.type !== "JSXElement")
            return;
          const attributeMap = vSlotMap.get(slotNode)?.attributeMap || vSlotMap.set(slotNode, {
            vSlotAttribute: tagName !== "template" ? vSlotAttribute : void 0,
            attributeMap: /* @__PURE__ */ new Map()
          }).get(slotNode).attributeMap;
          const children = attributeMap.get(vSlotAttribute)?.children || attributeMap.set(vSlotAttribute, {
            children: [],
            ...tagName === "template" ? {
              vIfAttribute,
              vForAttribute
            } : {}
          }).get(vSlotAttribute).children;
          if (slotNode === parent) {
            children.push(node);
            if (attributeMap.get(null))
              return;
            for (const child of parent.children) {
              if (child.type === "JSXElement" && s.sliceNode(child.openingElement.name, { offset }) === "template" || child.type === "JSXText" && !s.sliceNode(child, { offset }).trim())
                continue;
              const defaultNodes = attributeMap.get(null)?.children || attributeMap.set(null, { children: [] }).get(null).children;
              defaultNodes.push(child);
            }
          } else {
            children.push(...node.children);
          }
        }
      }
    });
    vIfMap.forEach((nodes) => transformVIf(nodes, s, offset, version));
    transformVFor(vForNodes, s, offset, version);
    version >= 3.2 && transformVMemo(vMemoNodes, s, offset);
    transformVHtml(vHtmlNodes, s, offset, version);
    transformVOn(vOnNodes, s, offset, version);
    transformVOnWithModifiers(vOnWithModifiers, s, offset, version);
    transformVSlot(vSlotMap, s, offset, version);
  }
  return generateTransform(s, id);
}

export {
  transformJsxDirective
};
