// src/export-expose.ts
var import_language_core2 = require("@vue/language-core");
var import_pluginutils = require("@rollup/pluginutils");

// src/common.ts
var import_language_core = require("@vue/language-core");
function getVolarOptions(vueCompilerOptions) {
  return vueCompilerOptions.vueMacros;
}

// src/export-expose.ts
function transform({
  fileName,
  file,
  sfc,
  ts,
  volarOptions
}) {
  const filter = (0, import_pluginutils.createFilter)(
    volarOptions.include || /.*/,
    volarOptions.exclude
  );
  if (!filter(fileName))
    return;
  const exposed = /* @__PURE__ */ Object.create(null);
  for (const stmt of sfc.scriptSetup.ast.statements) {
    if (ts.isExportDeclaration(stmt) && stmt.exportClause) {
      if (ts.isNamedExports(stmt.exportClause)) {
        const exportMap = /* @__PURE__ */ new Map();
        stmt.exportClause.elements.forEach((element) => {
          if (element.isTypeOnly)
            return;
          const name = element.name;
          const propertyName = element.propertyName || name;
          exportMap.set(
            [
              propertyName.text,
              "scriptSetup",
              propertyName.getStart(sfc.scriptSetup?.ast),
              import_language_core2.FileRangeCapabilities.full
            ],
            [
              name.text,
              "scriptSetup",
              name.getStart(sfc.scriptSetup?.ast),
              import_language_core2.FileRangeCapabilities.full
            ]
          );
          exposed[name.text] = propertyName.text;
        });
        if (stmt.moduleSpecifier) {
          const start = stmt.getStart(sfc.scriptSetup?.ast);
          const end = stmt.getEnd();
          (0, import_language_core2.replaceSourceRange)(
            file.content,
            "scriptSetup",
            start,
            start + 6,
            "import"
          );
          (0, import_language_core2.replaceSourceRange)(
            file.content,
            "scriptSetup",
            end,
            end,
            `;[${Array.from(exportMap.values()).map(([name]) => name)}];`
          );
        } else {
          (0, import_language_core2.replaceSourceRange)(
            file.content,
            "scriptSetup",
            stmt.getStart(sfc.scriptSetup?.ast),
            stmt.getEnd(),
            `(({`,
            ...Array.from(exportMap.entries()).flatMap(
              ([name, value]) => name[0] === value[0] ? [value, ","] : [name, ":", value, ","]
            ),
            `})=>{${Array.from(exportMap.values()).map(([name]) => name)}`,
            `})({${Array.from(exportMap.keys()).map(([name]) => name)}})`
          );
        }
      } else if (ts.isNamespaceExport(stmt.exportClause)) {
        const start = stmt.getStart(sfc.scriptSetup?.ast);
        const end = stmt.getEnd();
        (0, import_language_core2.replaceSourceRange)(
          file.content,
          "scriptSetup",
          start,
          start + 6,
          "import"
        );
        (0, import_language_core2.replaceSourceRange)(
          file.content,
          "scriptSetup",
          end,
          end,
          `;[${stmt.exportClause.name.text}];`
        );
      }
    } else if (ts.isVariableStatement(stmt) || ts.isFunctionDeclaration(stmt) || ts.isClassDeclaration(stmt)) {
      const exportModifier = stmt.modifiers?.find(
        (m) => m.kind === ts.SyntaxKind.ExportKeyword
      );
      if (!exportModifier)
        continue;
      const exposedValues = [];
      if (ts.isVariableStatement(stmt)) {
        for (const decl of stmt.declarationList.declarations) {
          if (!decl.name)
            continue;
          if (ts.isIdentifier(decl.name)) {
            const name = decl.name.text;
            exposed[name] = name;
          } else if (ts.isObjectBindingPattern(decl.name)) {
            decl.name.elements.forEach((element) => {
              if (!ts.isIdentifier(element.name))
                return;
              exposedValues.push(element.name.text);
              exposed[element.name.text] = element.propertyName && ts.isIdentifier(element.propertyName) ? element.propertyName.text : element.name.text;
            });
          }
        }
      } else if (stmt.name && ts.isIdentifier(stmt.name)) {
        const name = stmt.name.text;
        exposed[name] = name;
      }
      (0, import_language_core2.replaceSourceRange)(
        file.content,
        "scriptSetup",
        exportModifier.getStart(sfc.scriptSetup?.ast),
        exportModifier.getEnd(),
        exposedValues.length > 0 ? `[${exposedValues}];` : ""
      );
    }
  }
  if (Object.keys(exposed).length === 0)
    return;
  const exposedStrings = Object.entries(exposed).flatMap(([key, value]) => [
    `${key}: `,
    value,
    ",\n"
  ]);
  (0, import_language_core2.replaceAll)(
    file.content,
    /return {\n/g,
    "return {\n...{ ",
    ...exposedStrings,
    " },\n"
  );
}
var plugin = ({
  vueCompilerOptions,
  modules: { typescript: ts }
}) => {
  return {
    name: "vue-macros-export-expose",
    version: 1,
    resolveEmbeddedFile(fileName, sfc, embeddedFile) {
      if (embeddedFile.kind !== import_language_core2.FileKind.TypeScriptHostFile || !sfc.scriptSetup || !sfc.scriptSetup.ast)
        return;
      transform({
        fileName,
        file: embeddedFile,
        sfc,
        ts,
        volarOptions: getVolarOptions(vueCompilerOptions)?.exportExpose || {}
      });
    }
  };
};
module.exports = plugin;
