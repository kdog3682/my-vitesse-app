// src/jsx-directive.ts
var import_language_core8 = require("@vue/language-core");

// src/jsx-directive/v-slot.ts
var import_language_core3 = require("@vue/language-core");

// src/common.ts
var import_language_core = require("@vue/language-core");
function getPropsType(codes) {
  if (codes.toString().includes("type __VLS_getProps"))
    return;
  codes.push(`
type __VLS_getProps<T> = T extends new () => { $props: infer P }
  ? NonNullable<P>
  : T extends (props: infer P, ctx: any) => any
    ? NonNullable<P>
    : {};`);
}
function getEmitsType(codes) {
  if (codes.toString().includes("type __VLS_getEmits"))
    return;
  codes.push(`
type __VLS_getEmits<T> = T extends new () => { $emit: infer E }
  ? NonNullable<__VLS_NormalizeEmits<E>>
  : T extends (
        props: any,
        ctx: { slots: any; attrs: any; emit: infer E },
      ) => any
    ? NonNullable<__VLS_NormalizeEmits<E>>
    : {};`);
}
function getModelsType(codes) {
  if (codes.toString().includes("type __VLS_getModels"))
    return;
  getEmitsType(codes);
  getPropsType(codes);
  codes.push(`
type __VLS_CamelCase<S extends string> = S extends \`\${infer F}-\${infer RF}\${infer R}\`
  ? \`\${F}\${Uppercase<RF>}\${__VLS_CamelCase<R>}\`
  : S;
type __VLS_RemoveUpdatePrefix<T> = T extends \`update:modelValue\`
  ? never
  : T extends \`update:\${infer R}\`
    ? __VLS_CamelCase<R>
    : T;
type __VLS_getModels<T> = T extends object
  ? {
      [K in keyof __VLS_getEmits<T> as __VLS_RemoveUpdatePrefix<K>]: __VLS_getProps<T>[__VLS_RemoveUpdatePrefix<K>]
    }
  : {};`);
}
function getSlotsType(codes, vueVersion) {
  if (codes.toString().includes("type __VLS_getSlots"))
    return;
  codes.push(`
type __VLS_getSlots<T> = T extends new () => { '${(0, import_language_core.getSlotsPropertyName)(
    vueVersion || 3
  )}': infer S } ? NonNullable<S>
  : T extends (props: any, ctx: { slots: infer S; attrs: any; emit: any }) => any
  ? NonNullable<S>
  : {};`);
}

// src/jsx-directive/v-for.ts
var import_language_core2 = require("@vue/language-core");
function resolveVFor(attribute, { ts, sfc, source }) {
  const result = [];
  if (attribute.initializer && ts.isJsxExpression(attribute.initializer) && attribute.initializer.expression && ts.isBinaryExpression(attribute.initializer.expression)) {
    let index;
    let objectIndex;
    let item = attribute.initializer.expression.left;
    const list = attribute.initializer.expression.right;
    if (ts.isParenthesizedExpression(item)) {
      if (ts.isBinaryExpression(item.expression)) {
        if (ts.isBinaryExpression(item.expression.left)) {
          index = item.expression.left.right;
          objectIndex = item.expression.right;
          item = item.expression.left.left;
        } else {
          index = item.expression.right;
          item = item.expression.left;
        }
      } else {
        item = item.expression;
      }
    }
    if (item && list) {
      result.push(
        "__VLS_getVForSourceType(",
        [
          sfc[source].content.slice(list.getStart(sfc[source]?.ast), list.end),
          source,
          list.getStart(sfc[source]?.ast),
          import_language_core2.FileRangeCapabilities.full
        ],
        ").map(([",
        [
          `${sfc[source]?.content.slice(item.getStart(sfc[source]?.ast), item.end)}`,
          source,
          item.getStart(sfc[source]?.ast),
          import_language_core2.FileRangeCapabilities.full
        ],
        ", ",
        index ? [
          `${sfc[source]?.content.slice(index.getStart(sfc[source]?.ast), index.end)}`,
          source,
          index.getStart(sfc[source]?.ast),
          import_language_core2.FileRangeCapabilities.full
        ] : objectIndex ? "undefined" : "",
        ...objectIndex ? [
          ", ",
          [
            `${sfc[source]?.content.slice(objectIndex.getStart(sfc[source]?.ast), objectIndex.end)}`,
            source,
            objectIndex.getStart(sfc[source]?.ast),
            import_language_core2.FileRangeCapabilities.full
          ]
        ] : "",
        "]) => "
      );
    }
  }
  return result;
}
function transformVFor({
  nodes,
  codes,
  ts,
  sfc,
  source
}) {
  nodes.forEach(({ attribute, node, parent }) => {
    const result = resolveVFor(attribute, { ts, sfc, source });
    if (parent) {
      result.unshift("{");
    }
    (0, import_language_core2.replaceSourceRange)(codes, source, node.pos, node.pos, ...result);
    (0, import_language_core2.replaceSourceRange)(
      codes,
      source,
      node.end - 1,
      node.end,
      `>)${parent ? "}" : ""}`
    );
    (0, import_language_core2.replaceSourceRange)(codes, source, attribute.pos, attribute.end);
  });
}

// src/jsx-directive/v-slot.ts
function transformVSlot({
  nodeMap,
  codes,
  ts,
  sfc,
  source,
  vueVersion
}) {
  if (nodeMap.size === 0)
    return;
  getSlotsType(codes, vueVersion);
  nodeMap.forEach(({ attributeMap, vSlotAttribute }, node) => {
    const result = [" v-slots={{"];
    const attributes = Array.from(attributeMap);
    attributes.forEach(
      ([attribute, { children, vIfAttribute, vForAttribute }], index) => {
        if (!attribute)
          return;
        const vIfAttributeName = vIfAttribute?.name.getText(sfc[source]?.ast);
        if (vIfAttribute && vIfAttributeName) {
          if ("v-if" === vIfAttributeName) {
            result.push("...");
          }
          if (["v-if", "v-else-if"].includes(vIfAttributeName) && vIfAttribute.initializer && ts.isJsxExpression(vIfAttribute.initializer) && vIfAttribute.initializer.expression) {
            result.push(
              "(",
              [
                vIfAttribute.initializer.expression.getText(sfc[source]?.ast),
                source,
                vIfAttribute.initializer.expression.getStart(sfc[source]?.ast),
                import_language_core3.FileRangeCapabilities.full
              ],
              ") ? {"
            );
          } else if ("v-else" === vIfAttributeName) {
            result.push("{");
          }
        }
        if (vForAttribute) {
          result.push(
            "...",
            ...resolveVFor(vForAttribute, { ts, sfc, source }),
            "({"
          );
        }
        let isDynamic = false;
        let attributeName = attribute.name?.getText(sfc[source]?.ast).slice(6).split(" ")[0].replace(/\$(.*)\$/, (_, $1) => {
          isDynamic = true;
          return $1;
        });
        const isNamespace = attributeName.startsWith(":");
        attributeName = attributeName.slice(1);
        result.push(
          isNamespace ? [
            isDynamic ? `[${attributeName}]` : `'${attributeName}'`,
            source,
            attribute.name.getStart(sfc[source]?.ast) + (isDynamic ? 7 : 6),
            import_language_core3.FileRangeCapabilities.full
          ] : "default",
          `: (`,
          attribute.initializer && ts.isJsxExpression(attribute.initializer) && attribute.initializer.expression ? [
            attribute.initializer.expression.getText(sfc[source]?.ast),
            source,
            attribute.initializer.expression.getStart(sfc[source]?.ast),
            import_language_core3.FileRangeCapabilities.full
          ] : "",
          isDynamic ? ": any" : "",
          ") => <>",
          ...children.map((child) => {
            (0, import_language_core3.replaceSourceRange)(codes, source, child.pos, child.end);
            const node2 = ts.isJsxElement(child) && child.openingElement.tagName.getText(sfc[source]?.ast) === "template" ? child.children : child;
            return ts.isJsxSelfClosingElement(child) ? "" : [
              sfc[source].content.slice(node2.pos, node2.end),
              source,
              node2.pos,
              import_language_core3.FileRangeCapabilities.full
            ];
          }),
          "</>,"
        );
        if (vIfAttribute && vIfAttributeName) {
          if (["v-if", "v-else-if"].includes(vIfAttributeName)) {
            const nextIndex = index + (attributes[index + 1]?.[0] ? 1 : 2);
            result.push(
              "}",
              `${attributes[nextIndex]?.[1].vIfAttribute?.name.getText(
                sfc[source]?.ast
              )}`.startsWith("v-else") ? " : " : " : null,"
            );
          } else if ("v-else" === vIfAttributeName) {
            result.push("},");
          }
        }
        if (vForAttribute) {
          result.push("})),");
        }
      }
    );
    const tagName = ts.isJsxSelfClosingElement(node) ? node.tagName.getText(sfc[source]?.ast) : ts.isJsxElement(node) ? node.openingElement.tagName.getText(sfc[source]?.ast) : null;
    const slotType = `} satisfies __VLS_getSlots<typeof ${tagName}>}`;
    if (attributeMap.has(null)) {
      result.push("default: () => <>");
    } else {
      result.push(slotType);
    }
    if (vSlotAttribute) {
      (0, import_language_core3.replaceSourceRange)(
        codes,
        source,
        vSlotAttribute.pos,
        vSlotAttribute.end,
        ...result
      );
    } else if (ts.isJsxElement(node)) {
      (0, import_language_core3.replaceSourceRange)(
        codes,
        source,
        node.openingElement.end - 1,
        node.openingElement.end,
        ...result
      );
      (0, import_language_core3.replaceSourceRange)(
        codes,
        source,
        node.closingElement.pos,
        node.closingElement.pos,
        attributeMap.has(null) ? `</>${slotType}>` : ">"
      );
    }
  });
}

// src/jsx-directive/v-if.ts
var import_language_core4 = require("@vue/language-core");
function transformVIf({
  nodes,
  codes,
  ts,
  sfc,
  source
}) {
  nodes.forEach(({ node, attribute, parent }, index) => {
    if (!ts.isIdentifier(attribute.name))
      return;
    if (["v-if", "v-else-if"].includes(
      attribute.name.getText(sfc[source]?.ast)
    ) && attribute.initializer && ts.isJsxExpression(attribute.initializer) && attribute.initializer.expression) {
      const hasScope = parent && attribute.name.escapedText === "v-if";
      (0, import_language_core4.replaceSourceRange)(
        codes,
        source,
        node.pos,
        node.pos,
        `${hasScope ? "{" : " "}(`,
        [
          attribute.initializer.expression.getText(sfc[source]?.ast),
          source,
          attribute.initializer.expression.getStart(sfc[source]?.ast),
          import_language_core4.FileRangeCapabilities.full
        ],
        ") ? "
      );
      const nextAttribute = nodes[index + 1]?.attribute;
      const nextNodeHasElse = nextAttribute && ts.isIdentifier(nextAttribute.name) ? `${nextAttribute.name.escapedText}`.startsWith("v-else") : false;
      (0, import_language_core4.replaceSourceRange)(
        codes,
        source,
        node.end,
        node.end,
        nextNodeHasElse ? " : " : ` : null${parent ? "}" : ""}`
      );
    } else if (attribute.name.escapedText === "v-else") {
      (0, import_language_core4.replaceSourceRange)(codes, source, node.end, node.end, parent ? "}" : "");
    }
    (0, import_language_core4.replaceSourceRange)(codes, source, attribute.pos, attribute.end);
  });
}

// src/jsx-directive/v-model.ts
var import_language_core5 = require("@vue/language-core");
var import_shared = require("@vue/shared");
function transformVModel({
  nodes,
  codes,
  ts,
  sfc,
  source
}) {
  let firstNamespacedNode;
  const result = [];
  for (const { attribute: attribute2, node } of nodes) {
    const tagName2 = ts.isJsxSelfClosingElement(node) ? node.tagName.getText(sfc[source]?.ast) : ts.isJsxElement(node) ? node.openingElement.tagName.getText(sfc[source]?.ast) : "";
    const modelValue = ["input", "select", "textarea"].includes(tagName2) ? "value" : "modelValue";
    const isArrayExpression = attribute2.initializer && ts.isJsxExpression(attribute2.initializer) && attribute2.initializer.expression && ts.isArrayLiteralExpression(attribute2.initializer.expression);
    if (attribute2.name.getText(sfc[source]?.ast).startsWith("v-model:") || isArrayExpression) {
      let isDynamic = false;
      const attributeName = (0, import_shared.camelize)(
        attribute2.name.getText(sfc[source]?.ast).slice(8).split(" ")[0].split("_")[0].replace(/^\$(.*)\$/, (_, $1) => {
          isDynamic = true;
          return $1;
        })
      );
      firstNamespacedNode ??= { attribute: attribute2, tagName: tagName2 };
      if (firstNamespacedNode.attribute !== attribute2) {
        (0, import_language_core5.replaceSourceRange)(
          codes,
          source,
          attribute2.getStart(sfc[source]?.ast),
          attribute2.getEnd()
        );
        result.push(",");
      }
      if (isArrayExpression) {
        const { elements } = attribute2.initializer.expression;
        if (elements[1] && !ts.isArrayLiteralExpression(elements[1])) {
          isDynamic = !ts.isStringLiteral(elements[1]);
          result.push(
            isDynamic ? "[`${" : "",
            [
              elements[1].getText(sfc[source]?.ast),
              source,
              elements[1].getStart(sfc[source]?.ast),
              import_language_core5.FileRangeCapabilities.full
            ],
            isDynamic ? "}`]" : ""
          );
        } else {
          result.push(modelValue);
        }
        if (elements[0])
          result.push(":", [
            elements[0].getText(sfc[source]?.ast),
            source,
            elements[0].getStart(sfc[source]?.ast),
            import_language_core5.FileRangeCapabilities.full
          ]);
      } else {
        result.push(
          isDynamic ? "[`${" : "",
          [
            attributeName,
            source,
            [
              attribute2.name.getStart(sfc[source]?.ast) + 8,
              attribute2.name.getEnd()
            ],
            import_language_core5.FileRangeCapabilities.full
          ],
          isDynamic ? "}`]" : ""
        );
        if (attribute2.initializer && attributeName)
          result.push(":", [
            attribute2.initializer.getText(sfc[source]?.ast).slice(1, -1),
            source,
            attribute2.initializer.getStart(sfc[source]?.ast) + 1,
            import_language_core5.FileRangeCapabilities.full
          ]);
      }
    } else {
      (0, import_language_core5.replaceSourceRange)(
        codes,
        source,
        attribute2.name.getStart(sfc[source]?.ast),
        attribute2.name.getEnd() + 1,
        [
          modelValue,
          source,
          [attribute2.name.getStart(sfc[source]?.ast), attribute2.name.getEnd()],
          import_language_core5.FileRangeCapabilities.full
        ],
        "="
      );
    }
  }
  if (!firstNamespacedNode)
    return;
  const { attribute, tagName } = firstNamespacedNode;
  getModelsType(codes);
  (0, import_language_core5.replaceSourceRange)(
    codes,
    source,
    attribute.getStart(sfc[source]?.ast),
    attribute.getEnd(),
    `{...{`,
    ...result,
    `} satisfies __VLS_getModels<typeof ${tagName}>}`
  );
}

// src/jsx-directive/v-on.ts
var import_language_core6 = require("@vue/language-core");
function transformVOn({
  nodes,
  codes,
  ts,
  sfc,
  source
}) {
  if (nodes.length === 0)
    return;
  getEmitsType(codes);
  for (const { node, attribute } of nodes) {
    const tagName = ts.isJsxSelfClosingElement(node) ? node.tagName.getText(sfc[source]?.ast) : ts.isJsxElement(node) ? node.openingElement.tagName.getText(sfc[source]?.ast) : null;
    (0, import_language_core6.replaceSourceRange)(
      codes,
      source,
      attribute.getEnd() - 1,
      attribute.getEnd() - 1,
      ` satisfies __VLS_getEmits<typeof ${tagName}>`
    );
  }
}
function transformVOnWithModifiers({
  nodes,
  codes,
  sfc,
  source
}) {
  for (const { attribute } of nodes) {
    const attributeName = attribute.name.getText(sfc[source]?.ast).split("_")[0];
    (0, import_language_core6.replaceSourceRange)(
      codes,
      source,
      attribute.name.getStart(sfc[source]?.ast),
      attribute.name.end,
      [
        attributeName,
        source,
        [attribute.name.getStart(sfc[source]?.ast), attribute.name.getEnd()],
        import_language_core6.FileRangeCapabilities.full
      ]
    );
    if (!attribute.initializer)
      (0, import_language_core6.replaceSourceRange)(
        codes,
        source,
        attribute.name.end,
        attribute.name.end,
        "={() => {}}"
      );
  }
}

// src/jsx-directive/v-bind.ts
var import_language_core7 = require("@vue/language-core");
var import_shared2 = require("@vue/shared");
function transformVBind({
  nodes,
  codes,
  ts,
  sfc,
  source
}) {
  if (nodes.length === 0)
    return;
  getEmitsType(codes);
  for (const { attribute } of nodes) {
    let attributeName = attribute.name.getText(sfc[source]?.ast);
    if (attributeName.includes("-") && attribute.initializer && !ts.isStringLiteral(attribute.initializer)) {
      attributeName = (0, import_shared2.camelize)(attributeName);
      (0, import_language_core7.replaceSourceRange)(
        codes,
        source,
        attribute.name.getStart(sfc[source]?.ast),
        attribute.name.end,
        [
          attributeName,
          source,
          [attribute.name.getStart(sfc[source]?.ast), attribute.name.end],
          import_language_core7.FileRangeCapabilities.full
        ]
      );
    }
    if (attributeName.includes("_")) {
      (0, import_language_core7.replaceSourceRange)(
        codes,
        source,
        attribute.name.getStart(sfc[source]?.ast),
        attribute.name.end,
        [
          attributeName.split("_")[0],
          source,
          [attribute.name.getStart(sfc[source]?.ast), attribute.name.end],
          import_language_core7.FileRangeCapabilities.full
        ]
      );
    }
  }
}

// src/jsx-directive/index.ts
function transformJsxDirective({
  codes,
  sfc,
  ts,
  source,
  vueVersion
}) {
  function getTagName(node) {
    return ts.isJsxSelfClosingElement(node) ? node.tagName.getText(sfc[source]?.ast) : ts.isJsxElement(node) ? node.openingElement.tagName.getText(sfc[source]?.ast) : null;
  }
  const vIfMap = /* @__PURE__ */ new Map();
  const vForNodes = [];
  const vSlotMap = /* @__PURE__ */ new Map();
  const vModelMap = /* @__PURE__ */ new Map();
  const vOnNodes = [];
  const vOnWithModifiers = [];
  const vBindNodes = [];
  function walkJsxDirective(node, parent) {
    const tagName = getTagName(node);
    const properties = ts.isJsxElement(node) ? node.openingElement.attributes.properties : ts.isJsxSelfClosingElement(node) ? node.attributes.properties : [];
    let vIfAttribute;
    let vForAttribute;
    let vSlotAttribute;
    for (const attribute of properties) {
      if (!ts.isJsxAttribute(attribute))
        continue;
      const attributeName = attribute.name.getText(sfc[source]?.ast);
      if (["v-if", "v-else-if", "v-else"].includes(attributeName)) {
        vIfAttribute = attribute;
      } else if (attributeName === "v-for") {
        vForAttribute = attribute;
      } else if (/^v-slot(?=:\S*|$)/.test(attributeName)) {
        vSlotAttribute = attribute;
      } else if (/^v-model(?=[:_]\S*|$)/.test(attributeName)) {
        vModelMap.has(node) || vModelMap.set(node, []);
        vModelMap.get(node).push({
          node,
          attribute
        });
      } else if (attributeName === "v-on") {
        vOnNodes.push({ node, attribute });
      } else if (/^on[A-Z]\S*[_|-]\S+/.test(attributeName)) {
        vOnWithModifiers.push({ node, attribute });
      } else if (/^(?!v-)\S+[_|-]\S+/.test(attributeName)) {
        vBindNodes.push({ node, attribute });
      }
    }
    if (!(vSlotAttribute && tagName === "template")) {
      if (vIfAttribute) {
        vIfMap.has(parent) || vIfMap.set(parent, []);
        vIfMap.get(parent).push({
          node,
          attribute: vIfAttribute,
          parent
        });
      }
      if (vForAttribute) {
        vForNodes.push({
          node,
          attribute: vForAttribute,
          parent: vIfAttribute ? void 0 : parent
        });
      }
    }
    if (vSlotAttribute) {
      const slotNode = tagName === "template" ? parent : node;
      if (!slotNode)
        return;
      const attributeMap = vSlotMap.get(slotNode)?.attributeMap || vSlotMap.set(slotNode, {
        vSlotAttribute: tagName !== "template" ? vSlotAttribute : void 0,
        attributeMap: /* @__PURE__ */ new Map()
      }).get(slotNode).attributeMap;
      const children = attributeMap.get(vSlotAttribute)?.children || attributeMap.set(vSlotAttribute, {
        children: [],
        ...tagName === "template" ? {
          vIfAttribute,
          vForAttribute
        } : {}
      }).get(vSlotAttribute).children;
      if (slotNode === parent && ts.isJsxElement(parent)) {
        children.push(node);
        if (attributeMap.get(null))
          return;
        for (const child of parent.children) {
          if (getTagName(child) === "template" || ts.isJsxText(child) && !child.getText(sfc[source]?.ast).trim())
            continue;
          const defaultNodes = attributeMap.get(null)?.children || attributeMap.set(null, { children: [] }).get(null).children;
          defaultNodes.push(child);
        }
      } else if (ts.isJsxElement(node)) {
        children.push(...node.children);
      }
    }
    node.forEachChild((child) => {
      walkJsxDirective(
        child,
        ts.isJsxElement(node) || ts.isJsxFragment(node) ? node : void 0
      );
    });
  }
  sfc[source]?.ast.forEachChild(walkJsxDirective);
  transformVSlot({
    nodeMap: vSlotMap,
    codes,
    sfc,
    ts,
    source,
    vueVersion
  });
  transformVFor({ nodes: vForNodes, codes, sfc, ts, source });
  vIfMap.forEach((nodes) => transformVIf({ nodes, codes, sfc, ts, source }));
  vModelMap.forEach(
    (nodes) => transformVModel({ nodes, codes, sfc, ts, source })
  );
  transformVOn({ nodes: vOnNodes, codes, sfc, ts, source });
  transformVOnWithModifiers({ nodes: vOnWithModifiers, codes, sfc, ts, source });
  transformVBind({ nodes: vBindNodes, codes, sfc, ts, source });
}

// src/jsx-directive.ts
var plugin = ({
  modules: { typescript: ts },
  vueCompilerOptions
}) => {
  return {
    name: "vue-macros-jsx-directive",
    version: 1,
    resolveEmbeddedFile(fileName, sfc, embeddedFile) {
      if (embeddedFile.kind !== import_language_core8.FileKind.TypeScriptHostFile)
        return;
      for (const source of ["script", "scriptSetup"]) {
        transformJsxDirective({
          codes: embeddedFile.content,
          sfc,
          ts,
          source,
          vueVersion: vueCompilerOptions.target
        });
      }
    }
  };
};
module.exports = plugin;
