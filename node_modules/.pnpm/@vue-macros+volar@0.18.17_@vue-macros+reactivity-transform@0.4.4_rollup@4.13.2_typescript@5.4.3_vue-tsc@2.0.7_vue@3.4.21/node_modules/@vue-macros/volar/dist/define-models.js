// src/define-models.ts
var import_common = require("@vue-macros/common");
var import_language_core2 = require("@vue/language-core");

// src/common.ts
var import_language_core = require("@vue/language-core");
function getVueLibraryName(vueVersion) {
  return vueVersion < 2.7 ? "@vue/runtime-dom" : "vue";
}
function addProps(content, decl, vueLibName) {
  (0, import_language_core.replaceAll)(
    content,
    /setup\(\) {/g,
    "props: ({} as ",
    ...decl,
    "),\n",
    "setup() {"
  );
  content.push(
    `type __VLS_NonUndefinedable<T> = T extends undefined ? never : T;
`,
    `type __VLS_TypePropsToRuntimeProps<T> = { [K in keyof T]-?: {} extends Pick<T, K> ? { type: import('${vueLibName}').PropType<__VLS_NonUndefinedable<T[K]>> } : { type: import('${vueLibName}').PropType<T[K]>, required: true } };
`
  );
  return true;
}
function addEmits(content, decl) {
  (0, import_language_core.replaceAll)(
    content,
    /setup\(\) {/g,
    "emits: ({} as ",
    ...decl,
    "),\n",
    "setup() {"
  );
  return true;
}
function getVolarOptions(vueCompilerOptions) {
  return vueCompilerOptions.vueMacros;
}

// src/define-models.ts
function transformDefineModels({
  codes,
  sfc,
  typeArg,
  vueLibName,
  unified
}) {
  const source = sfc.scriptSetup.content.slice(typeArg.pos, typeArg.end);
  const seg = [
    source,
    "scriptSetup",
    typeArg.pos,
    import_language_core2.FileRangeCapabilities.full
  ];
  mergeProps() || addProps(
    codes,
    ["__VLS_TypePropsToRuntimeProps<__VLS_ModelToProps<", seg, ">>"],
    vueLibName
  );
  mergeEmits() || addEmits(codes, ["__VLS_ModelToEmits<", seg, ">"]);
  codes.push(
    `type __VLS_GetPropKey<K> = K extends 'modelValue'${unified ? "" : " & never"} ? 'value' : K
    type __VLS_ModelToProps<T> = {
      [K in keyof T as __VLS_GetPropKey<K>]: T[K]
    }
    type __VLS_GetEventKey<K extends string | number> = K extends 'modelValue'${unified ? "" : " & never"} ? 'input' : \`update:\${K}\`
    type __VLS_ModelToEmits<T> = T extends Record<string | number, any> ? { [K in keyof T & (string | number) as __VLS_GetEventKey<K>]: (value: T[K]) => void } : T;`
  );
  function mergeProps() {
    const indexes = codes.reduce((res, code, index) => {
      if (code === "__VLS_TypePropsToRuntimeProps<")
        res.unshift(index);
      return res;
    }, []);
    if (indexes.length === 0)
      return false;
    for (const idx of indexes)
      codes.splice(idx + 2, 0, " & __VLS_ModelToProps<", seg, ">");
    return true;
  }
  function mergeEmits() {
    const indexes = codes.reduce((res, code, index) => {
      if (code === "emits: ({} as __VLS_NormalizeEmits<typeof ")
        res.unshift(index);
      return res;
    }, []);
    if (indexes.length === 0)
      return false;
    for (const idx of indexes)
      codes.splice(idx + 2, 1, " & __VLS_ModelToEmits<", seg, ">>),\n");
    return true;
  }
}
function getTypeArg(ts, sfc) {
  function getCallArg(node) {
    if (!(ts.isCallExpression(node) && ts.isIdentifier(node.expression) && [import_common.DEFINE_MODELS, import_common.DEFINE_MODELS_DOLLAR].includes(node.expression.text) && node.typeArguments?.length === 1))
      return void 0;
    return node.typeArguments[0];
  }
  const sourceFile = sfc.scriptSetup.ast;
  return sourceFile.forEachChild((node) => {
    if (ts.isExpressionStatement(node)) {
      return getCallArg(node.expression);
    } else if (ts.isVariableStatement(node)) {
      return node.declarationList.forEachChild((decl) => {
        if (!ts.isVariableDeclaration(decl) || !decl.initializer)
          return;
        return getCallArg(decl.initializer);
      });
    }
  });
}
var plugin = ({
  modules: { typescript: ts },
  vueCompilerOptions
}) => {
  return {
    name: "vue-macros-define-models",
    version: 1,
    resolveEmbeddedFile(fileName, sfc, embeddedFile) {
      if (embeddedFile.kind !== import_language_core2.FileKind.TypeScriptHostFile || !sfc.scriptSetup || !sfc.scriptSetup.ast)
        return;
      const typeArg = getTypeArg(ts, sfc);
      if (!typeArg)
        return;
      const vueVersion = vueCompilerOptions.target;
      const vueLibName = getVueLibraryName(vueVersion);
      const volarOptions = getVolarOptions(vueCompilerOptions);
      const unified = vueVersion < 3 && (volarOptions?.defineModels?.unified ?? true);
      transformDefineModels({
        codes: embeddedFile.content,
        sfc,
        typeArg,
        vueLibName,
        unified
      });
    }
  };
};
module.exports = plugin;
